<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Arc Brick</title>
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, viewport-fit=cover">
<meta name="theme-color" content="#0b0d12">
<style>
  :root{
    --bg:#0b0d12;
    --panel:#141823;
    --fg:#e8ecf4;
    --muted:#a7b0c0;
    --glass:rgba(255,255,255,.06);
    --glassBorder:rgba(255,255,255,.12);
  }
  html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;touch-action:none;user-select:none;-webkit-user-select:none;overflow:hidden}
  canvas{display:block;width:100vw;height:100vh;max-height:100svh}
  .hud{
    position:fixed;inset:12px 12px auto 12px;display:flex;gap:10px;align-items:center;justify-content:space-between;pointer-events:none
  }
  .pill{
    backdrop-filter:blur(10px) saturate(120%);-webkit-backdrop-filter:blur(10px) saturate(120%);
    background:var(--glass);border:1px solid var(--glassBorder);border-radius:12px;padding:8px 12px;font-weight:700;letter-spacing:.2px;box-shadow:0 8px 30px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.06)
  }
  .btn{
    position:fixed;top:12px;right:12px;padding:10px 14px;border-radius:12px;background:rgba(255,255,255,.10);border:1px solid rgba(255,255,255,.18);color:#fff;font-weight:700;cursor:pointer;z-index:5
  }
  .hint{
    position:fixed;bottom:16px;left:50%;transform:translateX(-50%);
    backdrop-filter:blur(10px) saturate(120%);-webkit-backdrop-filter:blur(10px) saturate(120%);
    background:var(--glass);border:1px solid var(--glassBorder);border-radius:10px;padding:8px 12px;font-size:13px;color:var(--muted);pointer-events:none
  }
  .centerTitle{position:fixed;inset:0;display:grid;place-items:center;text-align:center;opacity:1;transition:opacity .3s}
  .centerTitle.hidden{opacity:0;pointer-events:none}
  .centerTitle h1{margin:0 0 8px 0;font-size:clamp(24px,6vw,42px)}
  .centerTitle p{margin:0;color:var(--muted)}
</style>
</head>
<body>
<canvas id="cv"></canvas>

<div class="hud">
  <div class="pill" id="score">Score 0</div>
  <div class="pill" id="balls">Balls 8</div>
</div>
<button class="btn" id="restart">Restart</button>
<div class="hint">Drag to aim. Release to shoot. Wait for balls to return.</div>
<div class="centerTitle" id="title">
  <div>
    <h1>Arc Brick</h1>
    <p>Clean aim and bounce brick game</p>
  </div>
</div>

<script>
(() => {
  const cv = document.getElementById('cv');
  const ctx = cv.getContext('2d', { alpha:false, desynchronized:true });

  const scoreEl = document.getElementById('score');
  const ballsEl = document.getElementById('balls');
  const titleEl = document.getElementById('title');

  const restartBtn = document.getElementById('restart');
  restartBtn.addEventListener('click', () => hardReset());

  let W=0, H=0, DPR=1;
  const margin = { t:96, r:18, b:92, l:18 };
  const field = () => ({ x:margin.l, y:margin.t, w:W - margin.l - margin.r, h:H - margin.t - margin.b });

  // soft pastel palette
  const pastel = ['#b7d4ff', '#f8c4ff', '#ffd6a5', '#caffbf', '#e6f3ff', '#ffcfe1', '#d7d7ff', '#c2f7e4'];
  const brickColors = ['#9ec6ff','#c7b7ff','#ffb6c8','#ffd39b','#bfe8c8','#f1c2ff','#b7e0ff','#ffd9e6'];

  // game state
  const S = {
    running:false,
    waiting:false, // waiting for all balls to return
    level:1,
    score:0,
    ammo:8,           // balls you own
    volleyCount:8,    // balls to fire this volley
    balls:[],
    bricks:[],
    grid:{ cols:7, rows:9, gap:8, cellW:0, cellH:0 },
    aim:{ active:false, startX:0, startY:0, endX:0, endY:0, path:[] },
    launcherX:0, // next volley spawn x
    firstCatchX:null
  };

  // setup and resize
  function resize(){
    DPR = Math.max(1, window.devicePixelRatio || 1);
    W = Math.floor(window.innerWidth);
    H = Math.floor(window.innerHeight);
    cv.width = Math.floor(W * DPR);
    cv.height = Math.floor(H * DPR);
    cv.style.width = W+'px';
    cv.style.height = H+'px';
    ctx.setTransform(DPR,0,0,DPR,0,0);
    placeGrid();
  }
  window.addEventListener('resize', resize, { passive:true });

  function placeGrid(){
    const f = field();
    S.grid.cols = clamp(Math.round(f.w / 60), 6, 9);
    S.grid.rows = 9;
    S.grid.gap = 8;
    S.grid.cellW = Math.floor((f.w - S.grid.gap*(S.grid.cols-1)) / S.grid.cols);
    S.grid.cellH = S.grid.cellW; // square
    if (!S.running) {
      S.launcherX = f.x + f.w * 0.5;
    }
  }

  // helpers
  const clamp = (v,a,b) => Math.max(a, Math.min(b,v));
  const sign = v => v<0?-1:1;
  function rrect(x,y,w,h,r){
    const rr = Math.min(r, w*.5, h*.5);
    ctx.beginPath();
    ctx.moveTo(x+rr,y);
    ctx.lineTo(x+w-rr,y);
    ctx.quadraticCurveTo(x+w,y,x+w,y+rr);
    ctx.lineTo(x+w,y+h-rr);
    ctx.quadraticCurveTo(x+w,y+h,x+w-rr,y+h);
    ctx.lineTo(x+rr,y+h);
    ctx.quadraticCurveTo(x,y+h,x,y+h-rr);
    ctx.lineTo(x,y+rr);
    ctx.quadraticCurveTo(x,y,x+rr,y);
    ctx.closePath();
  }

  // brick grid helpers
  function cellToXY(c,r){
    const f = field();
    const x = f.x + c*(S.grid.cellW + S.grid.gap);
    const y = f.y + r*(S.grid.cellW + S.grid.gap);
    return { x, y };
  }

  // build level row
  function addTopRow(){
    // shift rows down
    for(const b of S.bricks){ b.row += 1; }
    // game over if any brick moved into the catch line
    for(const b of S.bricks){
      const pos = cellToXY(b.col, b.row);
      if (pos.y + S.grid.cellH >= H - margin.b) {
        gameOver();
        return;
      }
    }
    // create new row
    const count = randInt(3, S.grid.cols);
    const spots = [...Array(S.grid.cols).keys()];
    shuffle(spots);
    for(let i=0;i<count;i++){
      const col = spots[i];
      const hp = S.level + randInt(1,3);
      S.bricks.push({
        col, row:0, hp,
        color: brickColors[(col + S.level) % brickColors.length]
      });
    }
    S.level += 1;
  }

  // physics
  const BALL_SPEED = 560;
  const BALL_R = 6;

  function fireVolley(){
    if (S.waiting) return;
    if (S.ammo <= 0) return;

    titleEl.classList.add('hidden');
    S.running = true;
    S.waiting = true;
    S.firstCatchX = null;

    const n = Math.min(S.volleyCount, S.ammo);
    const angle = Math.atan2(S.aim.endY - S.aim.startY, S.aim.endX - S.aim.startX);
    const base = { x:S.launcherX, y:H - margin.b - BALL_R - 2 };
    for(let i=0;i<n;i++){
      const jitter = 0.0025 * (i - n*0.5); // slight spread to reduce perfect overlap
      S.balls.push({
        x: base.x, y: base.y,
        vx: Math.cos(angle + jitter) * BALL_SPEED,
        vy: Math.sin(angle + jitter) * BALL_SPEED,
        alive:true, caught:false
      });
    }
    // consume nothing from ammo pool, since you own all balls, you just reuse them
  }

  function update(dt){
    const f = field();

    // balls
    let activeBalls = 0;
    for(const ball of S.balls){
      if (!ball.alive) continue;
      activeBalls++;

      ball.x += ball.vx * dt;
      ball.y += ball.vy * dt;

      // wall reflect
      if (ball.x - BALL_R <= f.x){ ball.x = f.x + BALL_R; ball.vx = Math.abs(ball.vx); }
      if (ball.x + BALL_R >= f.x + f.w){ ball.x = f.x + f.w - BALL_R; ball.vx = -Math.abs(ball.vx); }
      if (ball.y - BALL_R <= f.y){ ball.y = f.y + BALL_R; ball.vy = Math.abs(ball.vy); }

      // bottom catch
      if (ball.y + BALL_R >= H - margin.b){
        ball.alive = false;
        ball.caught = true;
        if (S.firstCatchX === null) S.firstCatchX = ball.x;
      }

      // brick collisions
      // check against possible bricks by coarse grid
      for (const br of S.bricks){
        const pos = cellToXY(br.col, br.row);
        const rx = pos.x, ry = pos.y, rw = S.grid.cellW, rh = S.grid.cellH;

        // circle rect intersect
        const cx = clamp(ball.x, rx, rx+rw);
        const cy = clamp(ball.y, ry, ry+rh);
        const dx = ball.x - cx, dy = ball.y - cy;
        if (dx*dx + dy*dy <= BALL_R*BALL_R){
          // decide reflection side
          const left = Math.abs((ball.x + BALL_R) - rx);
          const right = Math.abs((rx+rw) - (ball.x - BALL_R));
          const top = Math.abs((ball.y + BALL_R) - ry);
          const bottom = Math.abs((ry+rh) - (ball.y - BALL_R));
          const minPen = Math.min(left,right,top,bottom);
          if (minPen === left || minPen === right) ball.vx *= -1; else ball.vy *= -1;

          // damage brick
          br.hp -= 1;
          S.score += 1;
          if (br.hp <= 0){
            // remove
            S.bricks.splice(S.bricks.indexOf(br),1);
          }
        }
      }
    }

    if (S.waiting && activeBalls === 0){
      // volley ended, set next launcher x to first catch
      if (S.firstCatchX !== null) S.launcherX = clamp(S.firstCatchX, f.x + 10, f.x + f.w - 10);
      addTopRow();
      S.waiting = false;
      S.balls.length = 0;
    }

    scoreEl.textContent = 'Score ' + S.score;
    ballsEl.textContent = 'Balls ' + S.ammo;
  }

  // aiming preview with two bounces against walls and ceiling
  function buildAimPath(sx, sy, ex, ey){
    const f = field();
    const dirx = ex - sx, diry = ey - sy;
    let vx = dirx, vy = diry;
    const len = Math.hypot(vx, vy) || 1;
    vx /= len; vy /= len;

    // keep direction upward only
    if (vy > -0.05) vy = -0.05;

    const maxSeg = 3; // start to first, then two bounces
    const points = [{ x:sx, y:sy }];
    let px = sx, py = sy;

    for(let i=0;i<maxSeg;i++){
      // find time to hit vertical or horizontal bounds
      const tX = vx > 0 ? (f.x + f.w - px) / vx : (f.x - px) / vx;
      const tY = vy > 0 ? (H - margin.b - py) / vy : (f.y - py) / vy;

      let t = Math.min(Math.abs(tX), Math.abs(tY));
      t = clamp(t, 0, 2000);
      const nx = px + vx * t;
      const ny = py + vy * t;

      // clamp to edges
      let hitWall = '';
      if (nx <= f.x+0.1 || nx >= f.x + f.w - 0.1) hitWall = 'x';
      if (ny <= f.y+0.1) hitWall = 'y';
      if (ny >= H - margin.b) hitWall = 'bottom';

      points.push({ x:nx, y:ny });

      if (hitWall === 'x'){ vx *= -1; px = nx; py = ny; continue; }
      if (hitWall === 'y'){ vy *= -1; px = nx; py = ny; continue; }
      if (hitWall === 'bottom'){ break; }
    }
    return points;
  }

  // input
  let pointerDown = false;
  cv.addEventListener('pointerdown', e => {
    const f = field();
    pointerDown = true;
    S.aim.active = true;
    S.aim.startX = S.launcherX;
    S.aim.startY = H - margin.b - BALL_R - 2;
    S.aim.endX = clamp(e.clientX, f.x, f.x + f.w);
    S.aim.endY = clamp(e.clientY, f.y, H - margin.b);
    S.aim.path = buildAimPath(S.aim.startX, S.aim.startY, S.aim.endX, S.aim.endY);
  });
  cv.addEventListener('pointermove', e => {
    if (!pointerDown) return;
    const f = field();
    S.aim.endX = clamp(e.clientX, f.x, f.x + f.w);
    S.aim.endY = clamp(e.clientY, f.y, H - margin.b);
    S.aim.path = buildAimPath(S.aim.startX, S.aim.startY, S.aim.endX, S.aim.endY);
  });
  function release(){
    if (!pointerDown) return;
    pointerDown = false;
    if (!S.waiting) fireVolley();
    S.aim.active = false;
  }
  cv.addEventListener('pointerup', release);
  cv.addEventListener('pointercancel', release);
  cv.addEventListener('pointerleave', release);

  // draw
  function draw(){
    // background
    ctx.fillStyle = '#0b0d12';
    ctx.fillRect(0,0,W,H);

    // playfield panel
    const f = field();
    ctx.save();
    ctx.shadowColor = 'rgba(0,0,0,.50)';
    ctx.shadowBlur = 30;
    ctx.fillStyle = '#121624';
    rrect(f.x, f.y, f.w, f.h, 18);
    ctx.fill();
    ctx.restore();

    // subtle grid
    ctx.globalAlpha = .06;
    for(let c=1;c<S.grid.cols;c++){
      const x = f.x + c*(S.grid.cellW + S.grid.gap) - S.grid.gap*.5;
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(x, f.y, 1, f.h);
    }
    ctx.globalAlpha = 1;

    // bricks
    for(const br of S.bricks){
      const pos = cellToXY(br.col, br.row);
      const x = pos.x, y = pos.y, w = S.grid.cellW, h = S.grid.cellH;
      ctx.fillStyle = br.color;
      rrect(x, y, w, h, 10);
      ctx.fill();

      // hp label
      ctx.fillStyle = '#0b0d12';
      ctx.font = `600 ${Math.floor(w*0.36)}px Inter, system-ui, sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(br.hp, x + w*.5, y + h*.5 + 1);
    }

    // aim
    if (S.aim.active){
      // dotted path
      const pts = S.aim.path;
      ctx.lineWidth = 2;
      ctx.setLineDash([8, 10]);
      ctx.strokeStyle = 'rgba(255,255,255,.7)';
      ctx.beginPath();
      ctx.moveTo(pts[0].x, pts[0].y);
      for(let i=1;i<pts.length;i++) ctx.lineTo(pts[i].x, pts[i].y);
      ctx.stroke();
      ctx.setLineDash([]);

      // start indicator
      ctx.fillStyle = '#b7e0ff';
      ctx.beginPath();
      ctx.arc(S.aim.startX, S.aim.startY, 6, 0, Math.PI*2);
      ctx.fill();
    }

    // launcher marker
    ctx.globalAlpha = .6;
    ctx.fillStyle = '#c7b7ff';
    ctx.beginPath();
    ctx.arc(S.launcherX, H - margin.b, 4, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;

    // balls
    for(const ball of S.balls){
      if (!ball.alive) continue;
      const g = ctx.createRadialGradient(ball.x-3, ball.y-4, 0, ball.x, ball.y, 12);
      g.addColorStop(0, '#ffffff');
      g.addColorStop(1, '#bfe0ff');
      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.arc(ball.x, ball.y, BALL_R, 0, Math.PI*2);
      ctx.fill();
    }
  }

  // game loop
  let last = performance.now();
  function loop(now){
    const dt = Math.min(.033, (now - last) / 1000);
    last = now;
    if (S.running) update(dt);
    draw();
    requestAnimationFrame(loop);
  }

  // utils
  function randInt(a,b){ return Math.floor(a + Math.random()*(b-a+1)); }
  function shuffle(arr){ for(let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]]; } }

  // lifecycle
  function hardReset(){
    S.running = false;
    S.waiting = false;
    S.level = 1;
    S.score = 0;
    S.ammo = 8;
    S.volleyCount = 8;
    S.balls = [];
    S.bricks = [];
    S.firstCatchX = null;
    titleEl.classList.remove('hidden');

    // seed a couple of rows
    addTopRow();
    addTopRow();
  }

  function gameOver(){
    S.running = false;
    S.waiting = false;
    titleEl.classList.remove('hidden');
    titleEl.querySelector('h1').textContent = 'Game Over';
    titleEl.querySelector('p').textContent = 'Tap and drag to try again';
    // keep bricks so the player sees the failure state
  }

  // start
  resize();
  hardReset();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
