<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Arc Brick v3</title>
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, viewport-fit=cover">
<meta name="theme-color" content="#0b0d12">
<style>
  :root{
    --bg:#0b0d12;
    --panel:#121624;
    --fg:#e8ecf4;
    --muted:#a7b0c0;
    --glass:rgba(255,255,255,.06);
    --glassBorder:rgba(255,255,255,.12);
  }
  html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;touch-action:none;user-select:none;-webkit-user-select:none;overflow:hidden}
  canvas{display:block;width:100vw;height:100vh;max-height:100svh}

  .topbar{
    position:fixed;top:10px;left:10px;right:10px;display:grid;
    grid-template-columns:1fr auto 1fr;align-items:center;gap:10px;pointer-events:none;z-index:5
  }
  .pill{
    justify-self:start;
    backdrop-filter:blur(10px) saturate(120%);-webkit-backdrop-filter:blur(10px) saturate(120%);
    background:var(--glass);border:1px solid var(--glassBorder);border-radius:12px;padding:8px 12px;
    font-weight:700;letter-spacing:.2px;box-shadow:0 8px 30px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.06)
  }
  .pill.center{justify-self:center}
  .pill.right{justify-self:end}

  .hint{
    position:fixed;bottom:16px;left:50%;transform:translateX(-50%);
    backdrop-filter:blur(10px) saturate(120%);-webkit-backdrop-filter:blur(10px) saturate(120%);
    background:var(--glass);border:1px solid var(--glassBorder);border-radius:10px;padding:8px 12px;font-size:13px;color:var(--muted);pointer-events:none
  }
  .centerTitle{position:fixed;inset:0;display:grid;place-items:center;text-align:center;opacity:1;transition:opacity .3s}
  .centerTitle.hidden{opacity:0;pointer-events:none}
  .centerTitle h1{margin:0 0 8px 0;font-size:clamp(24px,6vw,42px)}
  .centerTitle p{margin:0;color:var(--muted)}
  .overlayBtn{
    position:fixed;top:50%;left:50%;transform:translate(-50%,-10px);
    padding:10px 16px;border-radius:12px;background:rgba(255,255,255,.10);border:1px solid rgba(255,255,255,.18);color:#fff;font-weight:700;cursor:pointer
  }
</style>
</head>
<body>
<canvas id="cv"></canvas>

<div class="topbar">
  <div class="pill" id="score">Score 0</div>
  <div class="pill center" id="balls">Balls 8</div>
  <div class="pill right" id="best">Best 0</div>
</div>

<div class="hint">Drag to aim. Release to shoot. Wait for balls to return.</div>

<div class="centerTitle" id="title">
  <div>
    <h1>Arc Brick</h1>
    <p>Clean aim and bounce brick game</p>
  </div>
  <button id="startBtn" class="overlayBtn">Start</button>
</div>

<script>
(() => {
  const cv = document.getElementById('cv');
  const ctx = cv.getContext('2d', { alpha:false, desynchronized:true });

  const scoreEl = document.getElementById('score');
  const ballsEl = document.getElementById('balls');
  const bestEl = document.getElementById('best');
  const titleEl = document.getElementById('title');
  const startBtn = document.getElementById('startBtn');

  let W=0, H=0, DPR=1;

  // margins are dynamic so we can create a comfy thumb zone
  const margin = { t:96, r:18, b:140, l:18 };
  function field(){
    return { x:margin.l, y:margin.t, w:W - margin.l - margin.r, h:H - margin.t - margin.b };
  }

  const S = {
    running:false,
    waiting:false,
    level:1,
    score:0,
    best:parseInt(localStorage.getItem('arcbrick_best')||'0',10),
    ammo:8,
    volleyCount:8,

    // volley spawning in sequence
    firing:false,
    toFire:0,
    fireDelay:0.07, // seconds between shots
    fireTimer:0,
    fireDir:{x:0,y:-1},

    balls:[],
    bricks:[],
    grid:{ cols:7, gap:8, cell:56 },
    aim:{ active:false, startX:0, startY:0, endX:0, endY:0, path:[], alpha:0 },
    launcherX:0,
    firstCatchX:null,
    particles:[]
  };
  bestEl.textContent = 'Best ' + S.best;

  // helpers
  const clamp = (v,a,b) => Math.max(a, Math.min(b,v));
  function rrect(x,y,w,h,r){
    const rr = Math.min(r, w*.5, h*.5);
    ctx.beginPath();
    ctx.moveTo(x+rr,y);
    ctx.lineTo(x+w-rr,y);
    ctx.quadraticCurveTo(x+w,y,x+w,y+rr);
    ctx.lineTo(x+w,y+h-rr);
    ctx.quadraticCurveTo(x+w,y+h,x+w-rr,y+h);
    ctx.lineTo(x+rr,y+h);
    ctx.quadraticCurveTo(x,y+h,x,y+h-rr);
    ctx.lineTo(x,y+rr);
    ctx.quadraticCurveTo(x,y,x+rr,y);
    ctx.closePath();
  }
  const randInt=(a,b)=>Math.floor(a+Math.random()*(b-a+1));
  function shuffle(arr){ for(let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]]; } }

  // colour per number
  function colorForHP(hp){
    const hue = (hp * 37) % 360;
    return `hsl(${hue} 64% 78%)`;
  }

  // bricks and power ups
  function addTopRow(){
    for(const b of S.bricks){ b.row += 1; }

    for(const b of S.bricks){
      const pos = cellToXY(b.col, b.row);
      if (pos.y + S.grid.cell >= H - margin.b){
        gameOver();
        return;
      }
    }

    const cols = S.grid.cols;
    const count = randInt(3, cols);
    const slots = [...Array(cols).keys()];
    shuffle(slots);

    let created = 0;
    for(let i=0;i<cols && created<count;i++){
      const col = slots[i];
      const roll = Math.random();
      if (roll < 0.10){
        S.bricks.push({ type:'plusball', col, row:0 });
      } else if (roll < 0.16){
        S.bricks.push({ type:'coin', col, row:0 });
      } else {
        const hp = S.level + randInt(1,3);
        S.bricks.push({ type:'brick', col, row:0, hp });
      }
      created++;
    }
    S.level += 1;
  }

  function placeGrid(){
    const f = field();
    const target = Math.round(f.w / 62);
    S.grid.cols = clamp(target, 6, 9);
    S.grid.cell = Math.floor((f.w - S.grid.gap*(S.grid.cols-1)) / S.grid.cols);
    if (!S.running) {
      S.launcherX = f.x + f.w * 0.5;
    }
  }

  function cellToXY(c,r){
    const f = field();
    const x = f.x + c*(S.grid.cell + S.grid.gap);
    const y = f.y + r*(S.grid.cell + S.grid.gap);
    return { x, y };
  }

  function resize(){
    DPR = Math.max(1, window.devicePixelRatio || 1);
    W = Math.floor(window.innerWidth);
    H = Math.floor(window.innerHeight);

    // set a taller thumb zone on small screens
    margin.b = Math.max(130, Math.floor(H*0.22));

    cv.width = Math.floor(W * DPR);
    cv.height = Math.floor(H * DPR);
    cv.style.width = W+'px';
    cv.style.height = H+'px';
    ctx.setTransform(DPR,0,0,DPR,0,0);
    placeGrid();
  }
  window.addEventListener('resize', resize, { passive:true });

  // particles
  function burst(x,y,base){
    for(let i=0;i<10;i++){
      const a = Math.random()*Math.PI*2;
      const s = 40+Math.random()*100;
      S.particles.push({x,y,vx:Math.cos(a)*s,vy:Math.sin(a)*s,t:0,life:.35,color:base});
    }
  }
  function updateParticles(dt){
    const out=[];
    for(const p of S.particles){
      p.t += dt;
      if (p.t < p.life){
        p.x += p.vx*dt;
        p.y += p.vy*dt;
        p.vy += 260*dt;
        out.push(p);
      }
    }
    S.particles = out;
  }
  function drawParticles(){
    for(const p of S.particles){
      const k = 1 - p.t/p.life;
      ctx.globalAlpha = k*.8;
      ctx.fillStyle = p.color;
      ctx.beginPath();
      ctx.arc(p.x, p.y, 2.5, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 1;
    }
  }

  // balls
  const BALL_SPEED = 560;
  const BALL_R = 6;

  function spawnOneBall(){
    const base = { x:S.launcherX, y:H - margin.b - BALL_R - 2 };
    S.balls.push({
      x: base.x, y: base.y,
      px: base.x, py: base.y,
      vx: S.fireDir.x * BALL_SPEED,
      vy: S.fireDir.y * BALL_SPEED,
      alive:true
    });
  }

  function fireVolley(){
    if (S.waiting || S.firing) return;
    titleEl.classList.add('hidden');
    S.running = true;
    S.waiting = true;

    const n = Math.min(S.volleyCount, S.ammo);
    const angle = Math.atan2(S.aim.endY - S.aim.startY, S.aim.endX - S.aim.startX);
    S.fireDir.x = Math.cos(angle);
    S.fireDir.y = Math.sin(angle);
    if (S.fireDir.y > -0.05) S.fireDir.y = -0.05;

    S.firing = true;
    S.toFire = n;
    S.fireTimer = 0;
    S.firstCatchX = null;
  }

  function update(dt){
    const f = field();

    // aim alpha ease
    const targetAlpha = S.aim.active ? 1 : 0;
    S.aim.alpha += (targetAlpha - S.aim.alpha) * Math.min(1, dt*12);

    // sequential spawning
    if (S.firing && S.toFire > 0){
      S.fireTimer += dt;
      while (S.fireTimer >= S.fireDelay && S.toFire > 0){
        spawnOneBall();
        S.fireTimer -= S.fireDelay;
        S.toFire -= 1;
      }
      if (S.toFire === 0) {
        S.firing = false;
      }
    }

    // move balls
    let aliveCount = 0;
    for(const ball of S.balls){
      if (!ball.alive) continue;
      aliveCount++;

      ball.px = ball.x; ball.py = ball.y;

      ball.x += ball.vx * dt;
      ball.y += ball.vy * dt;

      // walls
      if (ball.x - BALL_R <= f.x){ ball.x = f.x + BALL_R; ball.vx = Math.abs(ball.vx); }
      if (ball.x + BALL_R >= f.x + f.w){ ball.x = f.x + f.w - BALL_R; ball.vx = -Math.abs(ball.vx); }
      if (ball.y - BALL_R <= f.y){ ball.y = f.y + BALL_R; ball.vy = Math.abs(ball.vy); }

      // bottom catch
      if (ball.y + BALL_R >= H - margin.b){
        ball.alive = false;
        if (S.firstCatchX === null) S.firstCatchX = ball.x;
      }

      // collisions
      for (let i=S.bricks.length-1; i>=0; i--){
        const br = S.bricks[i];
        const pos = cellToXY(br.col, br.row);
        const rx = pos.x, ry = pos.y, rw = S.grid.cell, rh = S.grid.cell;

        const cx = clamp(ball.x, rx, rx+rw);
        const cy = clamp(ball.y, ry, ry+rh);
        const dx = ball.x - cx, dy = ball.y - cy;
        if (dx*dx + dy*dy <= BALL_R*BALL_R){
          const left = Math.abs((ball.x + BALL_R) - rx);
          const right = Math.abs((rx+rw) - (ball.x - BALL_R));
          const top = Math.abs((ball.y + BALL_R) - ry);
          const bottom = Math.abs((ry+rh) - (ball.y - BALL_R));
          const minPen = Math.min(left,right,top,bottom);
          if (minPen === left || minPen === right) ball.vx *= -1; else ball.vy *= -1;

          if (br.type === 'brick'){
            br.hp -= 1;
            S.score += 1;
            if (br.hp <= 0){
              burst(cx, cy, colorForHP(3));
              S.bricks.splice(i,1);
            }
          } else if (br.type === 'plusball'){
            S.ammo += 1;
            S.volleyCount = Math.min(S.ammo, S.volleyCount + 1);
            S.bricks.splice(i,1);
          } else if (br.type === 'coin'){
            S.score += 5;
            S.bricks.splice(i,1);
          }
        }
      }
    }

    if (S.waiting && aliveCount === 0 && !S.firing){
      if (S.firstCatchX !== null){
        S.launcherX = clamp(S.firstCatchX, f.x + 10, f.x + f.w - 10);
      }
      addTopRow();
      S.waiting = false;
      S.balls.length = 0;
    }

    updateParticles(dt);

    scoreEl.textContent = 'Score ' + S.score;
    ballsEl.textContent = 'Balls ' + S.ammo;
  }

  // aim preview with two segments only
  function buildAimPath(sx, sy, ex, ey){
    const f = field();
    let vx = ex - sx, vy = ey - sy;
    const len = Math.hypot(vx, vy) || 1;
    vx /= len; vy /= len;
    if (vy > -0.05) vy = -0.05;

    const pts = [{x:sx,y:sy}];
    let px = sx, py = sy;

    // first intersection against left right or top
    const tX = vx > 0 ? (f.x + f.w - px) / vx : (f.x - px) / vx;
    const tY = vy > 0 ? (H - margin.b - py) / vy : (f.y - py) / vy;
    let t1 = Math.min(Math.abs(tX), Math.abs(tY));
    t1 = clamp(t1, 0, 1e4);
    let nx = px + vx * t1;
    let ny = py + vy * t1;
    pts.push({x:nx,y:ny});

    // reflect once
    if (Math.abs(nx - f.x) < 0.5 || Math.abs(nx - (f.x + f.w)) < 0.5) vx *= -1;
    else if (Math.abs(ny - f.y) < 0.5) vy *= -1;

    px = nx; py = ny;

    // second segment end
    const tX2 = vx > 0 ? (f.x + f.w - px) / vx : (f.x - px) / vx;
    const tY2 = vy > 0 ? (H - margin.b - py) / vy : (f.y - py) / vy;
    let t2 = Math.min(Math.abs(tX2), Math.abs(tY2));
    t2 = clamp(t2, 0, 1e4);
    nx = px + vx * t2;
    ny = py + vy * t2;
    pts.push({x:nx,y:ny});

    // return exactly two segments
    return pts.slice(0,3);
  }

  // input
  let pointerDown = false;
  function pointerPos(e){ return { x:e.clientX, y:e.clientY }; }

  cv.addEventListener('pointerdown', e => {
    const f = field();
    pointerDown = true;
    S.aim.active = true;
    S.aim.startX = S.launcherX;
    S.aim.startY = H - margin.b - BALL_R - 2;
    const p = pointerPos(e);
    S.aim.endX = clamp(p.x, f.x, f.x + f.w);
    S.aim.endY = clamp(p.y, f.y, H - margin.b);
    S.aim.path = buildAimPath(S.aim.startX, S.aim.startY, S.aim.endX, S.aim.endY);
  });

  cv.addEventListener('pointermove', e => {
    if (!pointerDown) return;
    const f = field();
    const p = pointerPos(e);
    S.aim.endX = clamp(p.x, f.x, f.x + f.w);
    S.aim.endY = clamp(p.y, f.y, H - margin.b);
    S.aim.path = buildAimPath(S.aim.startX, S.aim.startY, S.aim.endX, S.aim.endY);
  });

  function release(){
    if (!pointerDown) return;
    pointerDown = false;
    fireVolley();
    S.aim.active = false;
  }
  cv.addEventListener('pointerup', release);
  cv.addEventListener('pointercancel', release);
  cv.addEventListener('pointerleave', release);

  startBtn.addEventListener('click', () => {
    titleEl.classList.add('hidden');
    S.running = true;
  });

  // draw
  function draw(){
    // background
    ctx.fillStyle = '#0b0d12';
    ctx.fillRect(0,0,W,H);

    const f = field();

    // playfield panel
    ctx.save();
    ctx.shadowColor = 'rgba(0,0,0,.50)';
    ctx.shadowBlur = 30;
    ctx.fillStyle = '#121624';
    rrect(f.x, f.y, f.w, f.h, 18);
    ctx.fill();
    ctx.restore();

    // subtle columns
    ctx.globalAlpha = .06;
    for(let c=1;c<S.grid.cols;c++){
      const x = f.x + c*(S.grid.cell + S.grid.gap) - S.grid.gap*.5;
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(x, f.y, 1, f.h);
    }
    ctx.globalAlpha = 1;

    // bricks and power ups
    for(const br of S.bricks){
      const pos = cellToXY(br.col, br.row);
      const x = pos.x, y = pos.y, w = S.grid.cell, h = S.grid.cell;
      if (br.type === 'brick'){
        ctx.fillStyle = colorForHP(br.hp);
        rrect(x, y, w, h, 12);
        ctx.fill();
        ctx.fillStyle = '#0b0d12';
        ctx.font = `600 ${Math.floor(w*0.36)}px Inter, system-ui, sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(br.hp, x + w*.5, y + h*.5 + 1);
      } else if (br.type === 'plusball'){
        ctx.fillStyle = 'hsl(150 55% 72%)';
        rrect(x, y, w, h, 12); ctx.fill();
        ctx.fillStyle = '#0b0d12';
        ctx.font = `700 ${Math.floor(w*0.36)}px Inter, system-ui, sans-serif`;
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.fillText('+1', x + w*.5, y + h*.5 + 1);
      } else if (br.type === 'coin'){
        ctx.fillStyle = 'hsl(42 85% 72%)';
        rrect(x, y, w, h, 12); ctx.fill();
        ctx.fillStyle = '#0b0d12';
        ctx.font = `700 ${Math.floor(w*0.34)}px Inter, system-ui, sans-serif`;
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.fillText('●', x + w*.5, y + h*.5 + 1);
      }
    }

    // aim path with smooth alpha
    if (S.aim.alpha > 0.01){
      const pts = S.aim.path;
      ctx.globalAlpha = 0.7 * S.aim.alpha;
      ctx.lineWidth = 2;
      ctx.setLineDash([8, 10]);
      ctx.strokeStyle = '#ffffff';
      ctx.beginPath();
      ctx.moveTo(pts[0].x, pts[0].y);
      ctx.lineTo(pts[1].x, pts[1].y);
      ctx.lineTo(pts[2].x, pts[2].y);
      ctx.stroke();
      ctx.setLineDash([]);
      // start marker and launcher glow
      ctx.fillStyle = '#b7e0ff';
      ctx.beginPath(); ctx.arc(S.aim.startX, S.aim.startY, 6, 0, Math.PI*2); ctx.fill();
      ctx.globalAlpha = 1;
    }

    // launcher marker and thumb zone gradient
    const thumbTop = H - margin.b;
    const grad = ctx.createLinearGradient(0, thumbTop, 0, H);
    grad.addColorStop(0, 'rgba(0,0,0,0)');
    grad.addColorStop(1, 'rgba(0,0,0,0.25)');
    ctx.fillStyle = grad;
    ctx.fillRect(0, thumbTop, W, margin.b);

    ctx.globalAlpha = .75;
    ctx.fillStyle = '#c7b7ff';
    ctx.beginPath(); ctx.arc(S.launcherX, H - margin.b, 4, 0, Math.PI*2); ctx.fill();
    ctx.globalAlpha = 1;

    // balls with soft trails
    for(const ball of S.balls){
      if (!ball.alive) continue;
      const dx = ball.x - ball.px;
      const dy = ball.y - ball.py;
      const len = Math.hypot(dx, dy);
      if (len > 0.1){
        const steps = 6;
        for(let i=1;i<=steps;i++){
          const k = i/steps;
          ctx.globalAlpha = 0.18*(1-k);
          ctx.fillStyle = '#bfe0ff';
          ctx.beginPath();
          ctx.arc(ball.x - dx*k, ball.y - dy*k, BALL_R*(1-k*0.6), 0, Math.PI*2);
          ctx.fill();
          ctx.globalAlpha = 1;
        }
      }
      const g = ctx.createRadialGradient(ball.x-3, ball.y-4, 0, ball.x, ball.y, 12);
      g.addColorStop(0, '#ffffff');
      g.addColorStop(1, '#bfe0ff');
      ctx.fillStyle = g;
      ctx.beginPath(); ctx.arc(ball.x, ball.y, BALL_R, 0, Math.PI*2); ctx.fill();
    }

    drawParticles();
  }

  // loop
  let last = performance.now();
  function loop(now){
    const dt = Math.min(.033, (now - last) / 1000);
    last = now;
    if (S.running) update(dt);
    draw();
    requestAnimationFrame(loop);
  }

  // lifecycle
  function resetGame(){
    S.waiting = false;
    S.firing = false;
    S.level = 1;
    S.score = 0;
    S.ammo = Math.max(8, S.ammo);
    S.volleyCount = Math.min(S.ammo, S.volleyCount || 8);
    S.balls = [];
    S.bricks = [];
    S.particles = [];
    S.firstCatchX = null;

    addTopRow();
    addTopRow();

    scoreEl.textContent = 'Score 0';
    ballsEl.textContent = 'Balls ' + S.ammo;
    titleEl.querySelector('h1').textContent = 'Arc Brick';
    titleEl.querySelector('p').textContent = 'Clean aim and bounce brick game';
  }

  function gameOver(){
    S.running = false;
    S.waiting = false;
    S.firing = false;
    if (S.score > S.best){
      S.best = S.score;
      localStorage.setItem('arcbrick_best', String(S.best));
      bestEl.textContent = 'Best ' + S.best;
    }
    titleEl.querySelector('h1').textContent = 'Game Over';
    titleEl.querySelector('p').textContent = `Score ${S.score}  Best ${S.best}`;
    titleEl.classList.remove('hidden');
  }

  function start(){
    resize();
    resetGame();
    requestAnimationFrame(loop);
  }
  start();

  startBtn.addEventListener('click', () => {
    titleEl.classList.add('hidden');
    S.running = true;
  });
})();
</script>
</body>
</html>
