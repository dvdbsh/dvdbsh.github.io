<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Brick Breaker, mobile POC</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, viewport-fit=cover">
  <meta name="theme-color" content="#0a0a0a">
  <style>
    html, body {
      margin: 0;
      height: 100%;
      background: radial-gradient(1200px 800px at 20% 10%, #1a1f2e 0%, #0d0f15 40%, #08090d 100%);
      overflow: hidden;
      touch-action: none;
      -webkit-user-select: none;
      user-select: none;
      color: #fff;
      font-family: system-ui, -apple-system, Segoe UI, Inter, Roboto, Helvetica, Arial, sans-serif;
    }
    .wrap {
      position: fixed;
      inset: env(safe-area-inset-top) 0 env(safe-area-inset-bottom) 0;
      display: grid;
      place-items: center;
    }
    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
      max-height: 100svh;
    }
    .hud {
      position: fixed;
      top: 12px;
      left: 12px;
      right: 12px;
      display: flex;
      justify-content: space-between;
      gap: 10px;
      pointer-events: none;
    }
    .hud .pill {
      backdrop-filter: blur(10px) saturate(130%);
      -webkit-backdrop-filter: blur(10px) saturate(130%);
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: 14px;
      padding: 8px 12px;
      font-weight: 600;
      letter-spacing: 0.2px;
      box-shadow: 0 8px 30px rgba(0,0,0,0.35), inset 0 1px 0 rgba(255,255,255,0.08);
    }
    .hint {
      position: fixed;
      bottom: 16px;
      left: 50%;
      transform: translateX(-50%);
      backdrop-filter: blur(10px) saturate(130%);
      -webkit-backdrop-filter: blur(10px) saturate(130%);
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: 12px;
      padding: 10px 14px;
      font-size: 13px;
      color: rgba(255,255,255,0.9);
      box-shadow: 0 8px 30px rgba(0,0,0,0.35), inset 0 1px 0 rgba(255,255,255,0.08);
      pointer-events: none;
    }
    .btn {
      position: fixed;
      top: 12px;
      right: 12px;
      padding: 10px 14px;
      font-weight: 700;
      background: rgba(255,255,255,0.12);
      border: 1px solid rgba(255,255,255,0.20);
      border-radius: 12px;
      box-shadow: 0 8px 30px rgba(0,0,0,0.35), inset 0 1px 0 rgba(255,255,255,0.10);
      color: #fff;
      cursor: pointer;
      z-index: 5;
    }
    .title {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%,-50%);
      text-align: center;
      color: white;
      pointer-events: none;
      opacity: 0;
      transition: opacity .35s ease;
    }
    .title.show { opacity: 1; }
    .title h1 {
      margin: 0 0 10px 0;
      font-size: clamp(24px, 6vw, 42px);
      letter-spacing: 0.5px;
      text-shadow: 0 12px 40px rgba(0,0,0,0.5);
    }
    .title p {
      margin: 0;
      opacity: 0.85;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <canvas id="game"></canvas>
  </div>

  <div class="hud">
    <div class="pill" id="score">Score 0</div>
    <div class="pill" id="lives">Lives 3</div>
  </div>

  <button class="btn" id="pauseBtn">Pause</button>
  <div class="hint">Drag to move the paddle, tap to launch</div>

  <div class="title show" id="title">
    <h1>Brick Breaker</h1>
    <p>Tap to start, drag to control</p>
  </div>

  <script>
  (() => {
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d', { alpha: false, desynchronized: true });
    const scoreEl = document.getElementById('score');
    const livesEl = document.getElementById('lives');
    const titleEl = document.getElementById('title');
    const pauseBtn = document.getElementById('pauseBtn');

    let W = 0, H = 0, DPR = Math.max(1, window.devicePixelRatio || 1);

    function resize() {
      W = Math.floor(window.innerWidth);
      H = Math.floor(window.innerHeight);
      canvas.width = Math.floor(W * DPR);
      canvas.height = Math.floor(H * DPR);
      canvas.style.width = W + 'px';
      canvas.style.height = H + 'px';
      ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
      layout();
    }
    window.addEventListener('resize', resize, { passive: true });

    // Game state
    const state = {
      running: false,
      paused: false,
      score: 0,
      lives: 3,
      level: 1,
      bricks: [],
      particles: [],
      paddle: { x: 0, y: 0, w: 120, h: 16, r: 8, speed: 1000 },
      ball: { x: 0, y: 0, r: 8, vx: 0, vy: 0, speed: 420, launched: false }
    };

    // Colours
    const palette = [
      '#8bd5ff', '#c8a6ff', '#ffadad', '#ffd6a5',
      '#fdffb6', '#caffbf', '#9bf6ff', '#bdb2ff'
    ];

    // Layout regions
    const margin = { t: 90, r: 16, b: 90, l: 16 };
    const grid = { cols: 8, rows: 5, gap: 6, top: 120, h: 24 };

    function layout() {
      state.paddle.w = Math.max(96, Math.min(160, W * 0.35));
      state.paddle.h = 16;
      state.paddle.x = W * 0.5 - state.paddle.w * 0.5;
      state.paddle.y = H - 80;

      state.ball.r = 8;
      state.ball.x = W * 0.5;
      state.ball.y = state.paddle.y - 16;
      state.ball.vx = 0;
      state.ball.vy = 0;
      state.ball.launched = false;

      grid.cols = Math.max(6, Math.min(12, Math.round(W / 70)));
      grid.rows = 5 + Math.min(4, state.level - 1);
      grid.top = 120;
      grid.h = 22;
      grid.gap = 6;

      buildLevel();
    }

    function buildLevel() {
      const cols = grid.cols;
      const gap = grid.gap;
      const padX = 12;
      const areaW = W - margin.l - margin.r - padX * 2;
      const brickW = Math.floor((areaW - gap * (cols - 1)) / cols);
      const rows = grid.rows;
      const startX = margin.l + padX;
      const startY = grid.top;

      state.bricks = [];
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          const x = startX + c * (brickW + gap);
          const y = startY + r * (grid.h + gap);
          const hp = 1 + Math.floor((r + state.level) % 3);
          const color = palette[(c + r) % palette.length];
          state.bricks.push({ x, y, w: brickW, h: grid.h, r: 6, hp, color });
        }
      }
    }

    // Rounded rect helper
    function rrect(x, y, w, h, r) {
      const rr = Math.min(r, w * 0.5, h * 0.5);
      ctx.beginPath();
      ctx.moveTo(x + rr, y);
      ctx.lineTo(x + w - rr, y);
      ctx.quadraticCurveTo(x + w, y, x + w, y + rr);
      ctx.lineTo(x + w, y + h - rr);
      ctx.quadraticCurveTo(x + w, y + h, x + w - rr, y + h);
      ctx.lineTo(x + rr, y + h);
      ctx.quadraticCurveTo(x, y + h, x, y + h - rr);
      ctx.lineTo(x, y + rr);
      ctx.quadraticCurveTo(x, y, x + rr, y);
      ctx.closePath();
    }

    // Particle system
    function spawnBurst(x, y, base) {
      for (let i = 0; i < 24; i++) {
        const a = Math.random() * Math.PI * 2;
        const s = 60 + Math.random() * 180;
        state.particles.push({
          x, y,
          vx: Math.cos(a) * s,
          vy: Math.sin(a) * s,
          life: 0.4 + Math.random() * 0.5,
          t: 0,
          color: base
        });
      }
    }

    function updateParticles(dt) {
      const out = [];
      for (const p of state.particles) {
        p.t += dt;
        if (p.t < p.life) {
          p.x += p.vx * dt;
          p.y += p.vy * dt;
          p.vy += 600 * dt * 0.5;
          out.push(p);
        }
      }
      state.particles = out;
    }

    function drawParticles() {
      for (const p of state.particles) {
        const k = 1 - p.t / p.life;
        ctx.globalAlpha = Math.max(0, k) * 0.9;
        ctx.fillStyle = p.color;
        rrect(p.x - 2, p.y - 2, 4, 4, 2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;
    }

    // Controls
    let pointerX = null;
    canvas.addEventListener('pointerdown', e => {
      const x = e.clientX;
      pointerX = x;
      if (!state.running) {
        titleEl.classList.remove('show');
        state.running = true;
      }
      if (!state.ball.launched) {
        launchBall();
      }
    });
    canvas.addEventListener('pointermove', e => {
      if (pointerX === null) return;
      pointerX = e.clientX;
    });
    canvas.addEventListener('pointerup', () => { pointerX = null; });
    canvas.addEventListener('pointercancel', () => { pointerX = null; });

    function launchBall() {
      if (state.ball.launched) return;
      state.ball.launched = true;
      const angle = degToRad(randRange(40, 140));
      state.ball.vx = Math.cos(angle) * state.ball.speed;
      state.ball.vy = Math.sin(angle) * state.ball.speed;
      // Ensure upward initial
      if (state.ball.vy > -120) state.ball.vy = -Math.abs(state.ball.vy);
    }

    function degToRad(d) { return d * Math.PI / 180; }
    function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
    function randRange(a, b) { return a + Math.random() * (b - a); }

    // Pause
    pauseBtn.addEventListener('click', () => {
      if (!state.running) return;
      state.paused = !state.paused;
      pauseBtn.textContent = state.paused ? 'Resume' : 'Pause';
    });

    // Update loop
    let last = performance.now();
    function loop(now) {
      const dt = Math.min(0.033, (now - last) / 1000);
      last = now;

      if (state.running && !state.paused) {
        step(dt);
      }
      draw();

      requestAnimationFrame(loop);
    }

    function step(dt) {
      // Paddle follow pointer with smoothing
      if (pointerX !== null) {
        const target = clamp(pointerX - state.paddle.w * 0.5, margin.l, W - margin.r - state.paddle.w);
        const dx = target - state.paddle.x;
        state.paddle.x += dx * Math.min(1, dt * 14);
      }

      // If not launched, keep ball over paddle
      if (!state.ball.launched) {
        state.ball.x = state.paddle.x + state.paddle.w * 0.5;
        state.ball.y = state.paddle.y - 16;
      } else {
        // Ball movement
        state.ball.x += state.ball.vx * dt;
        state.ball.y += state.ball.vy * dt;

        // Wall bounce
        if (state.ball.x - state.ball.r < margin.l) {
          state.ball.x = margin.l + state.ball.r;
          state.ball.vx *= -1;
        }
        if (state.ball.x + state.ball.r > W - margin.r) {
          state.ball.x = W - margin.r - state.ball.r;
          state.ball.vx *= -1;
        }
        if (state.ball.y - state.ball.r < margin.t) {
          state.ball.y = margin.t + state.ball.r;
          state.ball.vy *= -1;
        }

        // Out of bounds
        if (state.ball.y - state.ball.r > H + 40) {
          loseLife();
          return;
        }

        // Paddle collision
        if (rectCircleCollide(state.paddle, state.ball)) {
          // Position just above
          state.ball.y = state.paddle.y - state.ball.r - 0.5;
          state.ball.vy = -Math.abs(state.ball.vy);

          // Add english based on hit offset
          const hit = (state.ball.x - (state.paddle.x + state.paddle.w * 0.5)) / (state.paddle.w * 0.5);
          state.ball.vx += hit * 260;
          const sp = Math.hypot(state.ball.vx, state.ball.vy);
          const s = state.ball.speed * 1.02;
          state.ball.vx *= s / sp;
          state.ball.vy *= s / sp;
        }

        // Brick collisions
        const ball = state.ball;
        for (let i = 0; i < state.bricks.length; i++) {
          const b = state.bricks[i];
          if (!b) continue;
          if (rectCircleCollide(b, ball)) {
            // Resolve by finding the side with smallest overlap
            const overlapX = Math.min(Math.abs((ball.x + ball.r) - b.x), Math.abs((b.x + b.w) - (ball.x - ball.r)));
            const overlapY = Math.min(Math.abs((ball.y + ball.r) - b.y), Math.abs((b.y + b.h) - (ball.y - ball.r)));
            if (overlapX < overlapY) {
              ball.vx *= -1;
            } else {
              ball.vy *= -1;
            }
            hitBrick(i);
            break;
          }
        }
      }

      updateParticles(dt);

      // Win condition
      if (state.bricks.length === 0) {
        nextLevel();
      }
    }

    function rectCircleCollide(rect, circle) {
      const cx = clamp(circle.x, rect.x, rect.x + rect.w);
      const cy = clamp(circle.y, rect.y, rect.y + rect.h);
      const dx = circle.x - cx;
      const dy = circle.y - cy;
      return dx * dx + dy * dy <= circle.r * circle.r;
    }

    function hitBrick(index) {
      const b = state.bricks[index];
      if (!b) return;
      b.hp -= 1;
      spawnBurst(
        clamp(state.ball.x, b.x, b.x + b.w),
        clamp(state.ball.y, b.y, b.y + b.h),
        b.color
      );
      state.score += 10;
      scoreEl.textContent = 'Score ' + state.score;
      if (b.hp <= 0) {
        state.bricks.splice(index, 1);
      }
    }

    function loseLife() {
      state.lives -= 1;
      livesEl.textContent = 'Lives ' + state.lives;
      state.ball.launched = false;
      state.ball.vx = 0;
      state.ball.vy = 0;

      if (state.lives <= 0) {
        gameOver();
      }
    }

    function nextLevel() {
      state.level += 1;
      state.ball.launched = false;
      state.ball.speed *= 1.05;
      grid.rows = Math.min(10, grid.rows + 1);
      buildLevel();
    }

    function gameOver() {
      state.running = false;
      state.paused = false;
      pauseBtn.textContent = 'Pause';
      titleEl.innerHTML = '<h1>Game Over</h1><p>Tap to play again</p>';
      titleEl.classList.add('show');
      state.score = 0;
      scoreEl.textContent = 'Score 0';
      state.lives = 3;
      livesEl.textContent = 'Lives 3';
      state.level = 1;
      layout();
    }

    // Draw
    function draw() {
      // background mesh
      drawMesh();

      // playfield safe bounds glow
      ctx.save();
      ctx.shadowColor = 'rgba(0,0,0,0.6)';
      ctx.shadowBlur = 30;
      ctx.fillStyle = 'rgba(255,255,255,0.03)';
      rrect(margin.l, margin.t, W - margin.l - margin.r, H - margin.t - margin.b, 20);
      ctx.fill();
      ctx.restore();

      // bricks
      for (const b of state.bricks) {
        const grad = ctx.createLinearGradient(b.x, b.y, b.x, b.y + b.h);
        grad.addColorStop(0, b.color);
        grad.addColorStop(1, 'rgba(255,255,255,0.85)');
        ctx.fillStyle = grad;
        rrect(b.x, b.y, b.w, b.h, b.r);
        ctx.fill();

        // subtle highlight
        ctx.globalAlpha = 0.25;
        ctx.fillStyle = '#fff';
        rrect(b.x + 2, b.y + 2, b.w - 4, 6, 4);
        ctx.fill();
        ctx.globalAlpha = 1;
      }

      // paddle
      const p = state.paddle;
      ctx.fillStyle = '#e0e7ff';
      rrect(p.x, p.y, p.w, p.h, p.r);
      ctx.fill();
      ctx.globalAlpha = 0.25;
      ctx.fillStyle = '#fff';
      rrect(p.x + 2, p.y + 2, p.w - 4, 6, 6);
      ctx.fill();
      ctx.globalAlpha = 1;

      // ball
      const ball = state.ball;
      const g = ctx.createRadialGradient(ball.x - 3, ball.y - 5, 2, ball.x, ball.y, 12);
      g.addColorStop(0, '#ffffff');
      g.addColorStop(1, '#a0b2ff');
      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI * 2);
      ctx.fill();

      // particles
      drawParticles();
    }

    // Pretty background mesh
    const blobs = [
      { x: 0.25, y: 0.3, r: 260, c: 'rgba(139,213,255,0.12)', dx: 0.08, dy: 0.04 },
      { x: 0.72, y: 0.25, r: 220, c: 'rgba(200,166,255,0.12)', dx: -0.06, dy: 0.03 },
      { x: 0.40, y: 0.75, r: 280, c: 'rgba(255,173,173,0.10)', dx: 0.03, dy: -0.05 }
    ];
    function drawMesh() {
      ctx.fillStyle = '#0a0b10';
      ctx.fillRect(0, 0, W, H);
      const t = performance.now() * 0.001;
      for (const b of blobs) {
        const cx = W * (b.x + Math.sin(t * b.dx) * 0.03);
        const cy = H * (b.y + Math.cos(t * b.dy) * 0.03);
        const rad = b.r;
        const grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, rad);
        grad.addColorStop(0, b.c);
        grad.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(cx, cy, rad, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    // Start
    resize();
    requestAnimationFrame(loop);
  })();
  </script>
</body>
</html>
