<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
  <title>London News</title>
  <link href='https://unpkg.com/boxicons@2.1.4/css/boxicons.min.css' rel='stylesheet'>
  <link href="https://fonts.googleapis.com/css2?family=Lexend:wght@100..900&family=PT+Serif:ital,wght@0,400;0,700;1,400;1,700&family=Playfair+Display:ital,wght@0,400..900;1,400..900&display=swap" rel="stylesheet">
  <script src="https://unpkg.com/masonry-layout@4/dist/masonry.pkgd.min.js"></script>
  <!-- ColorThief for source-logo colour extraction -->
  <script src="https://unpkg.com/colorthief/dist/color-thief.umd.js"></script>
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#131313">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="mobile-web-app-capable" content="yes">

<style>
  :root {
    --bg: #121212;
    --fg: #ffffff;  
    --card-bg: #3a3b3f;
    --font: 'Lexend', sans-serif;
    --radius: 12px;
    --gutter: 32px;
    --col-count: 3;
    --col-width: calc((100% - (var(--gutter) * (var(--col-count) - 1))) / var(--col-count));
  }

  * {
    box-sizing: border-box;
  }

  body {
    margin: 0;
    font-family: var(--font);
    background: var(--bg);
    color: var(--fg);
    padding-top: calc(85px + env(safe-area-inset-top));
    display: flex;
    justify-content: center;
  }

.topbar {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  background: rgba(255,255,255,0.05);
  border-bottom: 1px solid rgba(255,255,255,0.2);
  backdrop-filter: blur(40px);
  font-weight: 500;
  font-size: 1.5rem;
  font-family: 'PT Serif';
  z-index: 1000;
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: calc(env(safe-area-inset-top) + 20px) 20px 20px; /* balanced top/bottom */
  height: calc(70px + env(safe-area-inset-top));
  transition: transform 0.45s ease, opacity 0.35s ease;
  line-height: 1.2;
}


  .topbar.hidden {
    transform: translateY(-100%);
    opacity: 0;
  }
  
	.weather-display {
	  display: flex;
	  align-items: center;
	  height: auto; /* let the content define height */
	}

.weather-display img {
  width: 38px;
  height: 38px;
  margin-left: 6px;
}
	
#currentWeather {
  display: flex;
  align-items: center;
  gap: 8px;
  line-height: 1.2;
}	

  .grid {
    max-width: 1200px;
    width: 100%;
    margin: 0 auto;
  }

  .grid-sizer {
    width: var(--col-width);
  }

  /* Base Card */
  .card {
    position: relative;
    width: var(--col-width);
    padding-top: 40px;
    margin-bottom: var(--gutter);
    border: 0 solid rgba(255,255,255,0.2);
    border-radius: var(--radius);
    overflow: hidden;
    background: var(--card-bg);
    color: var(--fg);
    transition: transform 0.25s ease, filter 0.25s ease;
    z-index: 0;
    cursor: pointer;
    box-shadow: 0 0 35px #0d0d0d;
  }

  .card::before {
    content: "";
    position: absolute;
    inset: 0;
    background: linear-gradient(to top, rgba(45,45,45,0.85), rgba(45,45,45,0.05));
    mix-blend-mode: multiply;
    z-index: 0;
  }

  .card-content {
    position: relative;
    z-index: 2;
    padding: 1rem;
    justify-content: flex-end;
    display: flex;
    flex-direction: column;
  }

  .card.image .card-content {
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    display: flex;
    flex-direction: column;
    justify-content: flex-end;
    height: 100%;
    padding: 1rem;
  }

  .card h2 {
    font-size: 1.9rem;
    font-weight: 700;
    font-family: 'Playfair Display';
    line-height: 1.1;
    margin: 0 0 0.5rem;
  }

  .card p {
    font-size: 1rem;
    font-weight: 400;
    line-height: 1.5;
    margin: 0;
  }

  .meta {
    font-size: 0.8rem;
    opacity: 0.9;
    font-weight: 600;
  }

  .card.image {
    background-size: cover;
    background-position: center;
    background-repeat: no-repeat;
    min-height: 300px;
  }

  /* Source Logo */
  .source-logo {
    position: absolute;
    top: 12px;
    left: 16px;
    z-index: 1;
	height: 34px;	
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: hidden;
    transition: filter 0.3s ease, opacity 0.3s ease;
    border-radius: 0px;
  }

  .source-logo img {
    width: 100%;
    height: 100%;
    object-fit: contain;
  }

  /* Overlay for image cards */
  .overlay {
    position: absolute;
    inset: 0;
    background: rgba(255,255,255,0);
    border: 0 solid rgba(255,255,255,0.2);
    border-radius: var(--radius);
    backdrop-filter: blur(40px);
    color: white;
    display: flex;
    flex-direction: column;
    justify-content: flex-end;
    padding: 2rem;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.3s ease;
    z-index: 4;
  }

  .overlay::after {
    content: "";
    position: absolute;
    inset: 0;
    pointer-events: none;
    background-image: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='150' height='150'><filter id='n'><feTurbulence type='fractalNoise' baseFrequency='0.8' numOctaves='2' stitchTiles='stitch'/></filter><rect width='150' height='150' filter='url(%23n)' opacity='0.3'/></svg>");
    background-repeat: repeat;
    background-size: 150px 150px;
    mix-blend-mode: overlay;
    opacity: 0.35;
    z-index: 5;
  }

  .overlay p {
    font-size: 1.1rem;
    margin-bottom: 1.5rem;
    opacity: 0.9;
    max-width: 50ch;
  }

  .overlay button {
    background: rgba(255,255,255,0.08);
    border: 1px solid rgba(255,255,255,0.2);
    backdrop-filter: blur(40px);
    color: white;
    font-weight: 400;
    font-size: 1.1rem;
    border-radius: 24px;
    padding: 0.6rem 1.4rem;
    cursor: pointer;
    transition: background 0.2s ease;
    width: 200px;
  }

  .overlay button:hover {
    background: rgba(255,255,255,0.2);
    backdrop-filter: blur(22px);
  }

  /* Open card state */
  .card.open .card-content,
  .card.open .source-logo {
    filter: blur(6px);
    opacity: 0.4;
  }

  .card.open:hover {
    filter: brightness(1);
  }

  .card.open .overlay {
    opacity: 1;
    pointer-events: all;
  }

  /* Toast */
  .toast {
    position: fixed;
    bottom: 24px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(255,255,255,0.08);
    border: 1px solid rgba(255,255,255,0.2);
    color: #fff;
    padding: 0.6rem 1.2rem;
    border-radius: 20px;
    font-weight: 800;
    opacity: 0;
    transition: opacity 0.35s ease;
    z-index: 9999;
    backdrop-filter: blur(10px);
  }

  .back-to-top {
    position: fixed;
    bottom: 32px;
    right: 32px;
    width: 62px;
    height: 62px;
    border: none;
    border-radius: 50%;
    background: rgba(255,255,255,0.08);
    border: 1px solid rgba(255,255,255,0.25);
    backdrop-filter: blur(20px);
    color: #fff;
    font-size: 1.8rem;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.4s ease, transform 0.3s ease, background 0.3s ease;
    z-index: 1000;
  }

  .back-to-top:hover {
    background: rgba(255,255,255,0.2);
    transform: translateY(-3px);
  }

  .back-to-top.visible {
    opacity: 1;
    pointer-events: auto;
  }

  @media (max-width: 1000px) {
    body {
      padding-top: calc(75px + env(safe-area-inset-top));
      padding-left: 20px;
      padding-right: 20px;
      background-color: #0a0a0a;
    }

    .grid {
      display: block;
      margin: 0;
      padding: 20px 0;
    }

    .grid-sizer {
      display: none;
    }

    .card {
      width: 100% !important;
      border-radius: var(--radius);
      border-bottom: 0 solid var(--bg);
      min-height: 220px;
      margin-bottom: 20px;
    }

    .card:last-child {
      border-bottom: none;
    }

    .overlay {
      border-radius: 0;
      border: 0;
    }
  }

  .card.mesh {
    position: relative;
    overflow: hidden;
    border-radius: var(--radius);
    color: var(--fg);
    cursor: pointer;
    transition: transform 0.25s ease, filter 0.25s ease;
    box-shadow: 0 0 15px #0d0d0d;
    display: grid;
  }

  /* Mesh Gradient Layer */
  .card.mesh::before {
    content: "";
    position: absolute;
    inset: 0;
    background:
      radial-gradient(at 20% 30%, rgba(255,255,255,0.15) 0%, transparent 70%),
      radial-gradient(at 80% 20%, rgba(255,0,150,0.25) 0%, transparent 60%),
      radial-gradient(at 40% 80%, rgba(0,200,255,0.25) 0%, transparent 70%),
      radial-gradient(at 70% 70%, rgba(255,200,0,0.2) 0%, transparent 65%);
    mix-blend-mode: overlay;
    opacity: 0.9;
    z-index: 0;
  }

  /* Noise overlay stays the same */
  .card.mesh .noise {
    position: absolute;
    inset: 0;
    background: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='150' height='150'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.6' numOctaves='2' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='150' height='150' filter='url(%23n)' opacity='0.25'/%3E%3C/svg%3E");
    background-repeat: repeat;
    background-size: 150px 150px;
    mix-blend-mode: none;
    opacity: 0.95;
    pointer-events: none;
    z-index: 1;
  }

  .card.mesh .card-content {
    align-self: end;
    display: flex;
    flex-direction: column;
    gap: 0.4rem;
    padding: 1rem 1rem 1.25rem;
    min-height: 0;
  }

  @media (min-width: 1001px) {
    .topbar {
      padding-left: calc((100% - 1200px) / 2);
      padding-right: calc((100% - 1200px) / 2);
    }
  }
</style>

</head>
<body>

  <div class="topbar" id="topbar">
    <div>London News</div>
    <div id="currentWeather">
      <span id="weatherText"></span>
    </div>
  </div>

  <div class="grid" id="grid">
    <div class="grid-sizer"></div>
  </div>

  <div class="toast" id="toast">Updated just now</div>
  <button id="backToTop" class="back-to-top" aria-label="Back to top">
    <i class='bx bx-up-arrow-alt'></i>
  </button>



  <script>
    /* ==============================
       Backend config from working app
    ============================== */
    const WORKER_BASE = "https://rss-proxy.davidbusch-02.workers.dev";
    const workerCached = (feedUrl) => `${WORKER_BASE}/cached?url=${encodeURIComponent(feedUrl)}`;
    const workerLive   = (feedUrl) => `${WORKER_BASE}/?url=${encodeURIComponent(feedUrl)}`;


    const grid = document.querySelector('#grid');
    const toastEl = document.getElementById('toast');

    let msnry = null;
    const gutterPx = () =>
      parseInt(getComputedStyle(document.documentElement).getPropertyValue('--gutter')) || 0;
    
    function enableMasonry(){
      if (msnry) return;
      msnry = new Masonry(grid, {
        itemSelector: '.card',
        columnWidth: '.grid-sizer',
        gutter: gutterPx(),
        percentPosition: true,
        horizontalOrder: true
      });
    }

    function disableMasonry(){
      if (!msnry) return;
      msnry.destroy();
      msnry = null;
      // clear Masonry’s inline positioning so normal flow stacks items
      grid.style.height = '';
      grid.style.position = '';
      grid.querySelectorAll('.card').forEach(el => {
        el.style.position = '';
        el.style.top = '';
        el.style.left = '';
      });
    }

    function relayout(){ if (msnry) msnry.layout(); }

    // turn Masonry on/off based on breakpoint
    const mq = window.matchMedia('(max-width: 1000px)');
    function applyLayout(e){ e.matches ? disableMasonry() : enableMasonry(); }
    mq.addEventListener ? mq.addEventListener('change', applyLayout)
                        : mq.addListener(applyLayout); // older Safari
    applyLayout(mq);


    /* ==============================
       Helpers from working app
    ============================== */
    function showToast(msg="Updated just now"){
      toastEl.textContent = msg;
      toastEl.style.opacity = '1';
      setTimeout(()=> toastEl.style.opacity = '0', 2200);
    }

    function stripHtmlTags(html) {
      if (!html) return '';
      const txt = document.createElement('textarea');
      txt.innerHTML = html;
      let decoded = txt.value;

      const temp = document.createElement('textarea');
      temp.innerHTML = decoded;
      decoded = temp.value;

      decoded = decoded.replace(/<\/?[^>]+(>|$)/g, '');
      decoded = decoded.replace(/\s+/g, ' ').trim();

      decoded = decoded
      .replace(/&nbsp;/gi, ' ')
      .replace(/&amp;/gi, '&')
      .replace(/&quot;/gi, '"')
      .replace(/&#039;/gi, "'")
      .replace(/&rsquo;/gi, "'")
      .replace(/&lsquo;/gi, "'")
      .replace(/&ldquo;/gi, '"')
      .replace(/&rdquo;/gi, '"')
      .replace(/&hellip;/gi, '…')
      .replace(/&mdash;/gi, '-')
      .replace(/&ndash;/gi, '-');


      return decoded.trim();
    }

    function truncateWords(text, n){
      const words = (text||'').trim().split(/\s+/);
      return words.length>n ? words.slice(0,n).join(' ') + '…' : text;
    }

    function decodeEntities(text) {
      if (!text) return '';
      const txt = document.createElement('textarea');
      txt.innerHTML = text;
      return txt.value;
    }

    function cleanTitle(title, sourceName) {
      if (!title) return "";
      title = decodeEntities(title);
      return title.replace(new RegExp(`[-|–|:|•]?\\s*${sourceName}\\s*$`, "i"), "").trim();
    }

    function normalizeHeadline(text) {
      if (!text) return "";
      text = decodeEntities(text);
      const letters = text.replace(/[^a-zA-Z]/g, "");
      const upperRatio = letters.replace(/[a-z]/g, "").length / (letters.length || 1);
      if (upperRatio > 0.8) {
        text = text.toLowerCase();
        text = text.replace(/^([“"‘'(\[]*)([a-z])/, (_, p, f) => p + f.toUpperCase());
        text = text.replace(/([.!?]\s+)([a-z])/g, (_, s, c) => s + c.toUpperCase());
      }
      return text
        .replace(/&nbsp;/gi, ' ')
        .replace(/&#039;/gi, "'")
        .replace(/&quot;/gi, '"')
        .replace(/&amp;/gi, '&')
        .replace(/&rsquo;/gi, "'")
        .replace(/&lsquo;/gi, "'")
        .replace(/&ldquo;/gi, '"')
        .replace(/&rdquo;/gi, '"')
        .replace(/&hellip;/gi, '…')
        .replace(/&mdash;/gi, '-')
        .replace(/&ndash;/gi, '-')
        .trim();

    }

    function formatArticleDate(pubDate) {
      const date = new Date(pubDate);
      if (isNaN(date)) return '';
      const day = date.toLocaleDateString('en-CA', { month: 'short', day: 'numeric' });
      const time = date.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit', hour12: true });
      return `${day} ${time}`;

    }

    // Source colour extraction using ColorThief, with graceful fallback
    async function getColorsFromLogo(logoUrl) {
        return new Promise(resolve => {
            const img = new Image();
            img.crossOrigin = 'Anonymous';
            img.src = logoUrl;

            img.onload = () => {
                try {
                    const thief = new ColorThief();
                    const base = thief.getColor(img) || [100, 100, 100];
                    const [r, g, b] = base;

                    // Slightly darkened and lightened versions
                    const dark = `rgb(${r * 0.6}, ${g * 0.6}, ${b * 0.6})`;
                    const light = `rgb(${Math.min(255, r * 1.3)}, ${Math.min(255, g * 1.3)}, ${Math.min(255, b * 1.3)})`;

                    resolve({ dark, light });
                } catch {
                    resolve({ dark: 'rgb(70,70,70)', light: 'rgb(130,130,130)' });
                }
            };

            img.onerror = () => resolve({ dark: 'rgb(70,70,70)', light: 'rgb(130,130,130)' });
        });
    }



    /* ==============================
       State
    ============================== */
    const state = {
      articles: [],
      allSources: [],
      sourceColors: new Map() // sourceName -> {sourceColor}
    };

    /* ==============================
       Card builders that match your Masonry front end
    ============================== */
    function buildImageCard(item, source, sourceColor) {
      const card = document.createElement('div');
      card.className = 'card image';
      card.dataset.url = item.link;
      card.style.backgroundImage = `url('${item.thumbnail}')`;

      const logoBox = document.createElement('div');
      logoBox.className = 'source-logo';
      if (source.logo) {
        const img = document.createElement('img');
        img.src = source.logo;
        img.alt = source.name;
        logoBox.appendChild(img);
      }
      card.appendChild(logoBox);

      const content = document.createElement('div');
      content.className = 'card-content';
      const h2 = document.createElement('h2');
      h2.textContent = truncateWords(normalizeHeadline(cleanTitle(item.title, source.name)), 18);
      const meta = document.createElement('span');
      meta.className = 'meta';
      meta.textContent = `${formatArticleDate(item.pubDate)} • ${source.name}`;
      content.appendChild(h2);
      content.appendChild(meta);
      card.appendChild(content);

      const overlay = document.createElement('div');
      overlay.className = 'overlay';
      const p = document.createElement('p');
      p.textContent = truncateWords(
        stripHtmlTags(item.content || item.description || '').replace(/Read More/gi, '').trim(),
        28
      );
      const btn = document.createElement('button');
      btn.textContent = 'Read Full Article';
      btn.addEventListener('click', e => {
        e.stopPropagation();
        window.open(item.link, '_blank', 'noopener');
      });
      overlay.appendChild(p);
      overlay.appendChild(btn);
      card.appendChild(overlay);

      // clicking image cards toggles preview
      card.addEventListener('click', e => {
        if (e.target.closest('button')) return;
        document.querySelectorAll('.card.open').forEach(c => { if (c !== card) c.classList.remove('open'); });
        card.classList.toggle('open');
        relayout();
      });

      return card;
    }

    function buildNoImageCard(item, source, colors) {
        const card = document.createElement('div');
        card.className = 'card mesh';
        card.dataset.url = item.link;

        const { dark, light } = colors || {};
        card.style.background = `
            radial-gradient(circle at 30% 20%, ${light} 0%, ${dark} 100%)
        `;

        // Add noise overlay
        card.style.backgroundBlendMode = 'overlay';
        card.style.position = 'relative';

        // Noise layer
        const noise = document.createElement('div');
        noise.className = 'noise';
        card.appendChild(noise);

        // Logo and content same as before
        const logoBox = document.createElement('div');
        logoBox.className = 'source-logo';
        if (source.logo) {
            const img = document.createElement('img');
            img.src = source.logo;
            img.alt = source.name;
            logoBox.appendChild(img);
        }
        card.appendChild(logoBox);

        const content = document.createElement('div');
        content.className = 'card-content';
        const h2 = document.createElement('h2');
        h2.textContent = truncateWords(normalizeHeadline(cleanTitle(item.title, source.name)), 18);
        const meta = document.createElement('span');
        meta.className = 'meta';
        meta.textContent = `${formatArticleDate(item.pubDate)} • ${source.name}`;
        content.appendChild(h2);
        content.appendChild(meta);
        card.appendChild(content);

        card.addEventListener('click', () => window.open(item.link, '_blank', 'noopener'));

        return card;
    }


    function appendCardToMasonry(card, hasImage) {
      grid.appendChild(card);
      if (msnry) msnry.appended(card);
      // For background-image, pre-load to reduce jumps
      if (hasImage) {
        const bg = card.style.backgroundImage;
        const match = bg.match(/url\(['"]?(.*?)['"]?\)/i);
        const url = match && match[1] ? match[1] : null;
        if (url) {
          const img = new Image();
          img.onload = () => relayout();
          img.onerror = () => relayout();
          img.src = url;
        } else {
          relayout();
        }
      } else {
        relayout();
      }
    }
	
	function asTimestamp(item){
      const cand = item.pubDate || item.isoDate || item.published || item.date;
      const t = Date.parse(cand);
      if (!Number.isNaN(t)) return t;
      // last resort, now
      return Date.now();
    }


    /* ==============================
       Feed loading
    ============================== */
    async function loadFeed(source) {
      const cachedUrl = workerCached(source.url);
      const liveUrl   = workerLive(source.url);
      let data = null;

      try {
        const cachedRes = await fetch(cachedUrl);
        if (cachedRes.ok) data = await cachedRes.json();
      } catch {}

      if (!data || !data.items || !data.items.length) {
        const liveRes = await fetch(liveUrl);
        data = await liveRes.json();
      }
      if (!data.items) return;

      // compute per-source colour once
      if (!state.sourceColors.has(source.name)) {
        const colors = await getColorsFromLogo(source.logo);
        state.sourceColors.set(source.name, colors);
      }
      const colors = state.sourceColors.get(source.name) || { dark: null, light: null };

      for (const item of data.items) {
        item.pubDate ||= item.isoDate || item.published || item.date || new Date().toISOString();

        let hasImage = !!item.thumbnail;
        if (hasImage && /placehold\.co/.test(item.thumbnail)) hasImage = false;

        const id = btoa(item.link);
        if (state.articles.some(a => a.id === id)) continue;

        const card = hasImage
          ? buildImageCard(item, source, colors)
          : buildNoImageCard(item, source, colors);


        state.articles.push({ ...item, id, sourceName: source.name, card });
        appendCardToMasonry(card, hasImage);
      }
    }

    async function loadAllFeeds() {
        // clear grid except sizer
        [...grid.querySelectorAll('.card')].forEach(n => n.remove());
        state.articles = [];

        try {
            const feedRes = await fetch('feeds.json');
            const feedData = await feedRes.json();
            state.allSources = Object.values(feedData).flat();

            // fetch all feeds in parallel, then combine
            const results = await Promise.all(state.allSources.map(async (src) => {
                // get brand colour once
                if (!state.sourceColors.has(src.name)) {
                    const colors = await getColorsFromLogo(src.logo);
                    state.sourceColors.set(src.name, colors);
                }
                const colors = state.sourceColors.get(src.name) || { dark: null, light: null };

                let data = null;
                try {
                    const cachedRes = await fetch(workerCached(src.url));
                    if (cachedRes.ok) data = await cachedRes.json();
                } catch {}
                if (!data || !data.items || !data.items.length) {
                    const liveRes = await fetch(workerLive(src.url));
                    data = await liveRes.json();
                }
                if (!data.items) return [];

                // normalize dates now so we can sort globally later
                return data.items.map(it => {
                    it.pubDate ||= it.isoDate || it.published || it.date || new Date().toISOString();
                    return { item: it, src, colors, ts: asTimestamp(it) };
                });
            }));

            // flatten and sort newest to oldest with deterministic tiebreaker
            const allArticles = results.flat();
            allArticles.sort((a, b) => (b.ts - a.ts) || String(a.item.link).localeCompare(String(b.item.link)));

            // render in sorted order, de-dupe by link
            const seen = new Set();
            const frag = document.createDocumentFragment();
            const newElems = [];

            for (const { item, src, colors } of allArticles) {
                const key = item.link || item.guid || item.id || JSON.stringify(item);
                if (seen.has(key)) continue;
                seen.add(key);

                const hasImage = !!item.thumbnail && !/placehold\.co/.test(item.thumbnail);
                const id = btoa(item.link || key);

                const card = hasImage
                  ? buildImageCard(item, src, colors)
                  : buildNoImageCard(item, src, colors);

                state.articles.push({ ...item, id, sourceName: src.name, card });
                frag.appendChild(card);
                newElems.push(card);
            }

            grid.appendChild(frag);
            msnry.appended(newElems);
            relayout();

            // cache summary
            localStorage.setItem('feedCache_masonry', JSON.stringify(state.articles.map(a => ({
                id: a.id,
                link: a.link,
                title: a.title,
                pubDate: a.pubDate,
                description: a.description || '',
                content: a.content || '',
                thumbnail: a.thumbnail || null,
                sourceName: a.sourceName || ''
            }))));
            localStorage.setItem('feedTimestamp_masonry', Date.now());
            showToast();
        } catch (err) {
            const errCard = document.createElement('div');
            errCard.className = 'card';
            errCard.innerHTML = '<div class="card-content"><h2>Error loading feeds</h2><p class="meta">' + err.message + '</p></div>';
            appendCardToMasonry(errCard, false);
        }
    }



    // cached boot
    fetch('feeds.json').then(r => r.json()).then(async feedData => {
        const sources = Object.values(feedData).flat();
        const byName = new Map(sources.map(s => [s.name, s]));

        const cacheItems = JSON.parse(saved)
            .map(ci => ({ ci, ts: asTimestamp(ci) }))
            .sort((a, b) => (b.ts - a.ts) || String(a.ci.link).localeCompare(String(b.ci.link)));

        const frag = document.createDocumentFragment();
        const newElems = [];

        for (const { ci } of cacheItems) {
            const src = byName.get(ci.sourceName) || { name: ci.sourceName || 'Source', logo: '' };

            if (!state.sourceColors.has(src.name)) {
                const colors = await getColorsFromLogo(src.logo);
                state.sourceColors.set(src.name, colors);
            }
            const colors = state.sourceColors.get(src.name) || { dark: null, light: null };

            const hasImage = !!ci.thumbnail && !/placehold\.co/.test(ci.thumbnail);
            const item = {
                link: ci.link, title: ci.title, pubDate: ci.pubDate,
                description: ci.description, content: ci.content, thumbnail: ci.thumbnail
            };

            const card = hasImage
                ? buildImageCard(item, src, colors)
                : buildNoImageCard(item, src, colors);

            state.articles.push({ ...item, id: ci.id, sourceName: src.name, card });
            frag.appendChild(card);
            newElems.push(card);
        }

        grid.appendChild(frag);
        msnry.appended(newElems);
        relayout();
    }).catch(() => {
        loadAllFeeds();
    });


/* ==============================
   Topbar: show weather only, scroll show-hide
============================== */
(function setDateAndWeather(){
  const el = document.getElementById('currentWeather');

  async function getWeather(){
    try {
      const res = await fetch("https://api.open-meteo.com/v1/forecast?latitude=42.9837&longitude=-81.2497&current_weather=true");
      const data = await res.json();
      const temp = Math.round(data.current_weather.temperature);
      const symbol = "°C";
      const code = data.current_weather.weathercode;

      // Map weather codes to your custom icons
      const iconMap = [
        { codes: [0], file: "clear_mostly-clear_day.png", label: "Clear" },
        { codes: [1, 2], file: "partly-cloudly_day.png", label: "Partly Cloudy" },
        { codes: [3], file: "cloudy.png", label: "Cloudy" },
        { codes: [45, 48], file: "fog.png", label: "Fog" },
        { codes: [51, 53, 55], file: "drizzle.png", label: "Drizzle" },
        { codes: [61, 63, 65], file: "rain.png", label: "Rain" },
        { codes: [66, 67], file: "freezing-rain.png", label: "Freezing Rain" },
        { codes: [71, 73, 75, 77, 85, 86], file: "snow.png", label: "Snow" },
        { codes: [80, 81, 82], file: "heavy-rain.png", label: "Showers" },
        { codes: [95, 96, 99], file: "thunderstorm.png", label: "Thunderstorm" },
        { codes: [99], file: "heavy-snow_blizzard.png", label: "Blizzard" },
        { codes: [55, 56, 57], file: "drizzle_night.png", label: "Drizzle" },
        { codes: [2], file: "partly-cloudly_day.png", label: "Partly Cloudy" },
        { codes: [3], file: "cloudy.png", label: "Cloudy" },
        { codes: [45], file: "fog.png", label: "Fog" },
        { codes: [95], file: "thunderstorm.png", label: "Thunderstorm" }
      ];

      const entry = iconMap.find(e => e.codes.includes(code)) || { file: "cloudy.png", label: "Weather" };

      // Return formatted HTML with your icon and weather text
      return `${temp}${symbol} • ${entry.label} <img src="images/weather/${entry.file}" alt="${entry.label}">`;
    } catch {
      return "Weather unavailable";
    }
  }

  // Show only the weather (no date rotation)
  getWeather().then(weatherHTML => {
    el.innerHTML = `<span class="weather-display">${weatherHTML}</span>`;
  });


  // scroll hide-show stays the same
  const topbar = document.getElementById('topbar');
  let lastScroll = 0;
  window.addEventListener('scroll', ()=>{
    const curr = window.scrollY;
    if(curr > lastScroll && curr > 80){ topbar.classList.add('hidden'); }
    else if(curr < lastScroll - 10){ topbar.classList.remove('hidden'); }
    lastScroll = curr;
  });
})();


    /* ==============================
       Click handler preserved from your template
    ============================== */
    grid.addEventListener('click', e => {
      const card = e.target.closest('.card');
      if (!card) return;
      if (!card.classList.contains('image')) {
        // no-image cards already navigate on click in builder
        return;
      }
      // image cards toggle preview in builder as well
    });
  </script>
  <script>
  /* ==============================
   Back to Top Button
============================== */
(function setupBackToTop() {
  const btn = document.getElementById('backToTop');
  if (!btn) return;

  // show/hide on scroll
  window.addEventListener('scroll', () => {
    if (window.scrollY > 400) btn.classList.add('visible');
    else btn.classList.remove('visible');
  });

  // smooth scroll to top
  btn.addEventListener('click', () => {
    window.scrollTo({ top: 0, behavior: 'smooth' });
  });
})();

</script>

</body>
</html>
