<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="mobile-web-app-capable" content="yes">
<title>London News</title>
<link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;600;800&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Zain:ital,wght@0,200;0,300;0,400;0,700;0,800;0,900;1,300;1,400&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Lexend:wght@100..900&display=swap" rel="stylesheet">
<link href="https://unpkg.com/boxicons@2.1.4/css/boxicons.min.css" rel="stylesheet">
<link rel="icon" href="favicon.ico">
<link rel="manifest" href="manifest.json">


<style>
:root{
  --blur-amount: 15px;
  --transition-speed: 0.25s;
  --overlay-color: rgba(0,0,0,0.25);
  --font: 'Lexend', sans-serif;
}

/* Page */
*{box-sizing:border-box}
html,body{height:100%}
body{
  margin:0;
  font-family:var(--font);
  background:#292a2d;
  color:#fff;
  display:flex;
  flex-direction:column;
  min-height:100vh;
  padding: calc(16px + env(safe-area-inset-top)) 16px calc(116px + env(safe-area-inset-bottom));
}

/* ==============================
   Frosted Top Bar
============================== */
.topbar {
  position: fixed;
  top: 0; left: 0; right: 0;
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: calc(env(safe-area-inset-top, 0px) + 0.75rem) 1.5rem 0.75rem;
  background: rgba(255,255,255,0.08);
  border-bottom: 1px solid rgba(255,255,255,0.2);
  backdrop-filter: blur(10px);
  z-index: 1000;
  transition: transform 0.45s ease, opacity 0.35s ease;
}
.topbar.hidden { transform: translateY(-100%); opacity: 0; }

.logo {
  display: flex;
  align-items: center;
  gap: 0.65rem;
}
.logo-icon {
  width: 45px;
  object-fit: contain;
  position: relative;
  top: -4px;
}
.logo-text {
  font-size: 1.15rem;
  font-weight: 800;
  color: #fff;
  opacity: 0.95;
}

.date {
  font-size: 1.15rem;
  font-weight: 800;
  color: #fff;
  opacity: 0.95;
  display: flex;
  align-items: center;
  gap: 0.35rem;
  transition: opacity 0.8s ease;
}

/* ==============================
   Controls
============================== */
.controls{ display:flex; gap:0.6rem; }
.btn{
  background:transparent;
  border:1px solid rgba(255,255,255,0.15);
  color:#fff;
  border-radius:999px;
  padding:0.5rem 0.9rem;
  cursor:pointer;
  font-weight:800;
  font-size: 1rem;
  transition:transform .2s, background .25s, border-color .25s;
}
.btn:hover{
  transform:translateY(-1px);
  background:rgba(255,255,255,0.06);
  border-color:rgba(255,255,255,0.25);
}

/* Toast */
.toast{
  position:fixed;
  bottom:110px;
  left:50%;
  transform:translateX(-50%);
  background:rgba(255,255,255,0.08);
  border:1px solid rgba(255,255,255,0.2);
  color:#fff;
  padding:0.6rem 1.2rem;
  border-radius:20px;
  font-weight:800;
  opacity:0;
  transition:opacity .35s ease;
  z-index:9999;
  backdrop-filter: blur(10px);
}

/* Floating Buttons */
.floating-controls {
  position: fixed;
  bottom: 1.5rem;
  right: 1.5rem;
  display: flex;
  flex-direction: column;
  gap: 0.8rem;
  z-index: 9999;
}
.float-btn {
  width: 62px;
  height: 62px;
  border-radius: 50%;
  color: #fff;
  font-size: 1.9rem;
  cursor: pointer;
  background: rgba(255,255,255,0.08);
  border: 1px solid rgba(255,255,255,0.2);
  backdrop-filter: blur(10px);
  transition: background 0.25s, transform 0.25s, opacity 0.25s;
  padding-top: 4px;
}
.float-btn:hover {
  background: rgba(255,255,255,0.15);
  transform: scale(1.08);
}
#backToTopBtn { opacity: 0; pointer-events: none; }
#backToTopBtn.visible { opacity: 1; pointer-events: auto; }

/* ==============================
   Grid Layout
============================== */
.grid{
  display:grid;
  grid-template-columns:repeat(auto-fill,minmax(300px,1fr));
  gap:1.5rem;
  width:100%;
  max-width:1200px;
  margin:72px auto 0;
}

/* ==============================
   Simplified Article Cards
============================== */
.card {
  position: relative;
  height: 420px;
  border-radius: 16px;
  overflow: hidden;
  cursor: pointer;
  background-color: var(--dark-source-color, #222);
  transition: transform 0.25s ease, backdrop-filter var(--transition-speed) ease;
  backdrop-filter: none;
}
.card.active {
  backdrop-filter: blur(var(--blur-amount));
  transform: scale(1.01);
}

.card-art {
  position: absolute;
  inset: 0;
  background-repeat: no-repeat;
  background-position: 50% 15%;
  background-size: 80%;
  transition: filter var(--transition-speed) ease;
  z-index: 1;
   
background-color: color-mix(in srgb, var(--source-color) 70%, white 30%);
mix-blend-mode: hard-light;

}

.card.active .card-art {
  filter: blur(var(--blur-amount)) brightness(0.9);
}

/* Source header */
.source-header {
  position: absolute;
  top: 0.8rem;
  left: 1.2rem;
  z-index: 3;
  display: flex;
  align-items: center;
  gap: 0.4rem;
}
.source-logo {
  width: 40px;
  object-fit: contain;
  border-radius: 3px;
}
.source-name { display: none; }

/* Info (title/meta) */
.info{
  position:absolute;
  bottom:0; left:0; right:0;
  padding:1.2rem;
  z-index:2;
  transition:opacity var(--transition-speed) ease;
}
.info h2{
  margin:0;
  font-size:1.75rem;
  line-height:1.1;
}
.info .meta{
  font-size:0.9rem;
  opacity:0.85;
  margin-top:0.4rem;
  font-weight:700;
}

/* Expanded content */
.content{
  position:absolute;
  inset:0;
  padding:1.5rem;
  display:flex;
  flex-direction:column;
  justify-content:flex-end;
  opacity:0;
  z-index:3;
  pointer-events:none;
  transition: opacity var(--transition-speed) ease;
}
.content p{
  font-size:1.2rem;
  line-height:1.4;
  margin-bottom:1rem;
  color:#e8eeff;
}
.content a{
  text-decoration:none;
  align-self:flex-start;
  background:rgba(255,255,255,0.08);
  border: 1px solid rgba(255,255,255,0.2);
  backdrop-filter: blur(10px);
  color:#fff;
  border-radius:24px;
  padding:0.6rem 1.2rem;
  font-weight:800;
  transition: background 0.25s, transform 0.25s;
}
.content a:hover{ transform:scale(1.05); background:rgba(255,255,255,0.15); }

/* Toggle states */
.card.active .source-header,
.card.active .info { opacity:0; }
.card.active .content { opacity:1; pointer-events:auto; }

/* Empty state */
.empty{
  grid-column:1/-1;
  background:rgba(255,255,255,0.04);
  border:1px dashed rgba(255,255,255,0.15);
  padding:2rem;
  margin:20px;
  border-radius:16px;
  text-align:center;
  color:#e8eeff;
  font-weight:800;
}

/* ==============================
   Mobile
============================== */
@media (max-width: 768px) {
  body {
    padding: calc(52.8px + env(safe-area-inset-top)) 16px calc(116px + env(safe-area-inset-bottom));
  }
  .grid {
    display: flex;
    flex-direction: column;
    gap: 0;
    width: 100vw;
    max-width: none;
    margin: 0 calc(-1 * 16px);
  }
  .card {
    border-radius: 0;
    min-height: 360px;
    border-bottom: 10px solid #0d0d0d;
  }
  .info, .content { padding: 1.25rem; }
}

/* ==============================
   Share Button
============================== */
.share-btn {
  position: absolute;
  top: 1.2rem;
  right: 1.2rem;
  width: 26px;
  height: 26px;
  background:transparent;
  border:1px solid rgba(255,255,255,0.15);
  border-radius:50%;
  color: #fff;
  font-size: 1rem;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  z-index: 10;
  backdrop-filter: blur(10px);
  transition: background 0.25s, transform 0.25s;
}
.share-btn:hover {
  background: rgba(255,255,255,0.15);
  transform: scale(1.08);
}

/* ==============================
   Icons
============================== */
.bx-spin { animation: bx-reverse-spin 2s linear infinite !important; }
@keyframes bx-reverse-spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(-360deg); }
}
</style>

</head>
<body>

<div class="topbar" id="topbar">
  <div class="logo">
    <img src="images/LN-logo-svg.svg" alt="London News Logo" class="logo-icon">
    <span class="logo-text">London News</span>
  </div>
  <div class="date" id="currentDate"></div>
</div>


<div class="grid" id="grid"></div>

<div class="toast" id="toast">Updated just now</div>

<div class="floating-controls">
  <button id="backToTopBtn" class="float-btn">
    <i class='bx bx-up-arrow-alt'></i>
  </button>
  <button id="refreshBtn" class="float-btn">
    <i class='bx bx-refresh'></i>
  </button>
</div>

<script>
/* ---------- Config ---------- */
const PEXELS_API_KEY = 'fB6vzEHx5CsDIVByIpuDfQ2QoliM9TYWyBqmkzPgj6nPeEuWdBvbtJIx';
const gridEl = document.getElementById('grid');
const toastEl = document.getElementById('toast');
const WORKER_BASE = "https://rss-proxy.davidbusch-02.workers.dev";

const workerCached = (feedUrl) =>
  `${WORKER_BASE}/cached?url=${encodeURIComponent(feedUrl)}`;
const workerLive = (feedUrl) =>
  `${WORKER_BASE}/?url=${encodeURIComponent(feedUrl)}`;

/* ---------- State ---------- */
const state = {
  articles: [],
  allSources: [],
  openCard: null
};


/* ---------- Toast ---------- */
function showToast(msg="Updated just now"){
  toastEl.textContent = msg;
  toastEl.style.opacity = '1';
  setTimeout(()=> toastEl.style.opacity = '0', 2200);
}

/* ---------- Helpers ---------- */
function stripHtmlTags(html) {
  if (!html) return '';
  const txt = document.createElement('textarea');
  txt.innerHTML = html;
  let decoded = txt.value;

  // Decode any double-encoded entities (e.g., &#039; inside RSS)
  const temp = document.createElement('textarea');
  temp.innerHTML = decoded;
  decoded = temp.value;

  // Remove HTML tags and collapse whitespace
  decoded = decoded.replace(/<\/?[^>]+(>|$)/g, '');
  decoded = decoded.replace(/\s+/g, ' ').trim();

  // Replace leftover entities that browsers donâ€™t decode automatically
  decoded = decoded
    .replace(/&nbsp;/gi, ' ')
    .replace(/&amp;/gi, '&')
    .replace(/&quot;/gi, '"')
    .replace(/&#039;/gi, "'")
    .replace(/&rsquo;/gi, "'")
    .replace(/&lsquo;/gi, "'")
    .replace(/&ldquo;/gi, '"')
    .replace(/&rdquo;/gi, '"')
    .replace(/&hellip;/gi, 'â€¦')
    .replace(/&mdash;/gi, '-')
    .replace(/&ndash;/gi, '-');

  return decoded.trim();
}

function truncateWords(text, n){
  const words = (text||'').trim().split(/\s+/);
  return words.length>n ? words.slice(0,n).join(' ') + 'â€¦' : text;
}
function decodeEntities(text) {
  if (!text) return '';
  const txt = document.createElement('textarea');
  txt.innerHTML = text;
  return txt.value;
}

function cleanTitle(title, sourceName) {
  if (!title) return "";
  title = decodeEntities(title);
  return title.replace(new RegExp(`[-|â€“|:|â€¢]?\\s*${sourceName}\\s*$`, "i"), "").trim();
}

function normalizeHeadline(text) {
  if (!text) return "";
  text = decodeEntities(text); // decode again here just in case
  const letters = text.replace(/[^a-zA-Z]/g, "");
  const upperRatio = letters.replace(/[a-z]/g, "").length / (letters.length || 1);
  if (upperRatio > 0.8) {
    text = text.toLowerCase();
    text = text.replace(/^([â€œ"â€˜'(\[]*)([a-z])/, (_, p, f) => p + f.toUpperCase());
    text = text.replace(/([.!?]\s+)([a-z])/g, (_, s, c) => s + c.toUpperCase());
  }
  return text
    .replace(/&nbsp;/gi, ' ')
    .replace(/&#039;/gi, "'")
    .replace(/&quot;/gi, '"')
    .replace(/&amp;/gi, '&')
    .replace(/&rsquo;/gi, "'")
    .replace(/&lsquo;/gi, "'")
    .replace(/&ldquo;/gi, '"')
    .replace(/&rdquo;/gi, '"')
    .replace(/&hellip;/gi, 'â€¦')
    .replace(/&mdash;/gi, '-')
    .replace(/&ndash;/gi, '-')
    .trim();
}

function formatArticleDate(pubDate) {
  const date = new Date(pubDate);
  if (isNaN(date)) return ''; // safety
  const day = date.toLocaleDateString('en-CA', { month: 'short', day: 'numeric' });
  const time = date.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit', hour12: true });
  return `${day} ${time}`;
}


/* Color utilities for faithful-but-pretty colours */
function beautifyColor(r,g,b){
  r/=255; g/=255; b/=255;
  const max=Math.max(r,g,b), min=Math.min(r,g,b);
  let h,s,l=(max+min)/2;
  if(max===min){ h=s=0; }
  else{
    const d=max-min;
    s = l>0.5 ? d/(2-max-min) : d/(max+min);
    switch(max){
      case r: h=(g-b)/d + (g<b?6:0); break;
      case g: h=(b-r)/d + 2; break;
      case b: h=(r-g)/d + 4; break;
    }
    h/=6;
  }
  s = Math.min(0.7, s*1.2);
  l = Math.min(0.6, l*1.3);
  const hue2rgb=(p,q,t)=>{
    if(t<0) t+=1; if(t>1) t-=1;
    if(t<1/6) return p+(q-p)*6*t;
    if(t<1/2) return q;
    if(t<2/3) return p+(q-p)*(2/3 - t)*6;
    return p;
  };
  let r2,g2,b2;
  if(s===0){ r2=g2=b2=l; }
  else{
    const q=l<0.5 ? l*(1+s) : l + s - l*s;
    const p=2*l-q;
    r2=hue2rgb(p,q,h+1/3);
    g2=hue2rgb(p,q,h);
    b2=hue2rgb(p,q,h-1/3);
  }
  return [Math.round(r2*255),Math.round(g2*255),Math.round(b2*255)];
}
function rgbToHsl(r,g,b){
  r/=255; g/=255; b/=255;
  const max=Math.max(r,g,b), min=Math.min(r,g,b);
  let h,s,l=(max+min)/2;
  if(max===min){ h=s=0; }
  else{
    const d=max-min;
    s = l>0.5 ? d/(2-max-min) : d/(max+min);
    switch(max){
      case r: h=(g-b)/d + (g<b?6:0); break;
      case g: h=(b-r)/d + 2; break;
      case b: h=(r-g)/d + 4; break;
    }
    h/=6;
  }
  return [h,s,l];
}
function hslToRgb(h,s,l){
  const hue2rgb=(p,q,t)=>{
    if(t<0) t+=1; if(t>1) t-=1;
    if(t<1/6) return p+(q-p)*6*t;
    if(t<1/2) return q;
    if(t<2/3) return p+(q-p)*(2/3 - t)*6;
    return p;
  };
  let r,g,b;
  if(s===0){ r=g=b=l; }
  else{
    const q=l<0.5 ? l*(1+s) : l + s - l*s;
    const p=2*l-q;
    r=hue2rgb(p,q,h+1/3);
    g=hue2rgb(p,q,h);
    b=hue2rgb(p,q,h-1/3);
  }
  return [Math.round(r*255),Math.round(g*255),Math.round(b*255)];
}

/* Extract brand-ish colours from the source logo (with fallbacks) */
async function getGradientFromLogo(logoUrl) {
  return new Promise(resolve => {
    const img = new Image();
    img.crossOrigin = 'Anonymous';
    img.src = logoUrl;

    img.onload = () => {
      try {
        const thief = new ColorThief();
        let palette = thief.getPalette(img, 8);
        if (!palette || !palette.length) throw new Error("No palette found");

        // Compute vibrancy scores
        const rgbToHsl = (r,g,b) => {
          r/=255; g/=255; b/=255;
          const max=Math.max(r,g,b), min=Math.min(r,g,b);
          let h,s,l=(max+min)/2;
          if(max===min){h=s=0;}
          else{
            const d=max-min;
            s=l>0.5?d/(2-max-min):d/(max+min);
            switch(max){
              case r:h=(g-b)/d+(g<b?6:0);break;
              case g:h=(b-r)/d+2;break;
              case b:h=(r-g)/d+4;break;
            }
            h/=6;
          }
          return {h,s,l};
        };

        const scored = palette.map(([r,g,b])=>{
          const {s,l}=rgbToHsl(r,g,b);
          const distance = Math.sqrt(
            (r-128)**2 + (g-128)**2 + (b-128)**2
          )/255; // prefer colours far from neutral grey
          const score = (s*1.3) + (distance*0.7) - Math.abs(l-0.5);
          return {rgb:[r,g,b],score};
        }).sort((a,b)=>b.score-a.score);

        const [r,g,b] = scored[0].rgb;

        // create tones
        const {h,s,l} = rgbToHsl(r,g,b);
        const light = hslToRgb(h, s*0.9, Math.min(1,l*1.4));
        const dark = hslToRgb(h, s, Math.max(0, l * (l > 0.6 ? 0.25 : 0.4)));
        const rgbStr = ([r,g,b])=>`rgb(${r},${g},${b})`;

        resolve({
          gradient: `
            radial-gradient(at 20% 30%, ${rgbStr(light)}, transparent 60%),
            radial-gradient(at 80% 70%, ${rgbStr([r,g,b])}, ${rgbStr(dark)} 80%)
          `,
          sourceColor: rgbStr([r,g,b]),
          darkSourceColor: rgbStr(dark),
          lightSourceColor: rgbStr(light)
        });

      } catch (err) {
        // fallback colour
        resolve({
          gradient: 'radial-gradient(circle, #555, #222)',
          sourceColor: 'rgb(85,85,85)',
          darkSourceColor: 'rgb(34,34,34)',
          lightSourceColor: 'rgb(110,110,110)'
        });
      }
    };

    img.onerror = () => resolve({
      gradient: 'radial-gradient(circle, #555, #222)',
      sourceColor: 'rgb(85,85,85)',
      darkSourceColor: 'rgb(34,34,34)',
      lightSourceColor: 'rgb(110,110,110)'
    });
  });
}



/* Optional Pexels fallback (kept from your previous build) */
//async function getPexelsImage(query){
//  const key = 'pexels_' + query.toLowerCase();
//  const cached = localStorage.getItem(key);
//  if (cached) return cached;
//  try {
//    const res = await fetch(`https://api.pexels.com/v1/search?query=${encodeURIComponent(query)}&per_page=1`, {
//      headers: { Authorization: PEXELS_API_KEY }
//    });
//    const data = await res.json();
//    const url = data.photos?.[0]?.src?.landscape || null;
//    if (url) localStorage.setItem(key, url);
//    return url;
//  } catch {
//    return null;
//  }
//}

/* ---------- Local Image Library ---------- */
let imageLibrary = [];

async function loadImageLibrary() {
  if (imageLibrary.length) return imageLibrary;
  try {
    const res = await fetch('library.json', { cache: 'no-store' });
    if (!res.ok) throw new Error(`library.json HTTP ${res.status}`);
    const data = await res.json();
    imageLibrary = Object.entries(data).map(([filename, tags]) => ({
      filename,
      tags: (tags || []).map(t => String(t).toLowerCase())
    }));
    // expose for debugging only
    window.imageLibrary = imageLibrary;
    console.log('Loaded imageLibrary:', imageLibrary.length, 'items');
    return imageLibrary;
  } catch (err) {
    console.error('Failed to load library.json:', err);
    imageLibrary = [];
    window.imageLibrary = imageLibrary;
    return imageLibrary;
  }
}


function extractKeywords(text) {
  if (!text) return [];
  return text
    .toLowerCase()
    .replace(/[^a-z0-9\s]/g, '')
    .split(/\s+/)
    .filter(w => w.length > 2);
}


function findBestImageForHeadline(headline) {
  const keywords = extractKeywords(headline);
  if (!keywords.length || !imageLibrary.length) return null;

  let best = null;
  let bestScore = 0;

  for (const item of imageLibrary) {
    let score = 0;
    for (const key of keywords) {
      if (item.tags.includes(key)) score += 5;
      else if (item.tags.some(t => t.includes(key))) score += 3;
      else if (item.tags.some(t => key.includes(t))) score += 2;
    }
    if (score > bestScore) {
      bestScore = score;
      best = item;
    }
  }
  console.log("Headline:", headline, "â†’", best?.filename, "score:", bestScore);
  return bestScore >= 1 ? best.filename : null;
}


/* ---------- Rendering ---------- */
function makeCardDOM(item, source) {
  const card = document.createElement('div');
  card.className = 'card';
  card.dataset.source = source.name;
  
  // --- Local image selection ---
  let localImage = null;
  if (imageLibrary.length) {
    localImage = findBestImageForHeadline(item.title);
  }
  const chosen = localImage || 'News.svg';
  
  // --- Background colour ---
  card.style.backgroundColor = source._colors?.darkSourceColor || '#222';
  
  // --- Foreground SVG layer ---
  const svgLayer = document.createElement('div');
  svgLayer.className = 'card-art';
  svgLayer.style.backgroundImage = `url('images/articles/${chosen}')`;
  card.appendChild(svgLayer);






  // --- Source header ---
  const header = document.createElement('div');
  header.className = 'source-header';
  if (source.logo) {
    const logo = document.createElement('img');
    logo.src = source.logo;
    logo.alt = source.name;
    logo.className = 'source-logo';
    header.appendChild(logo);
  }
  const name = document.createElement('span');
  name.textContent = source.name;
  name.className = 'source-name';
  header.appendChild(name);
  card.appendChild(header);

  // --- Info ---
  const info = document.createElement('div');
  info.className = 'info';
  const h2 = document.createElement('h2');
  h2.textContent = truncateWords(normalizeHeadline(cleanTitle(item.title, source.name)), 18);
  const meta = document.createElement('div');
  meta.className = 'meta';
  meta.textContent = `${formatArticleDate(item.pubDate)} â€¢ ${source.name}`;
  info.appendChild(h2);
  info.appendChild(meta);
  card.appendChild(info);

  // --- Content ---
  const content = document.createElement('div');
  content.className = 'content';
  const p = document.createElement('p');
  p.textContent = truncateWords(
    stripHtmlTags(item.content || item.description || '')
      .replace(/Read More/gi, '')
      .trim(),
    44
  );
  const blurLayer = document.createElement('div');
  blurLayer.part = 'blur';
  card.appendChild(blurLayer);

  const a = document.createElement('a');
  a.href = item.link;
  a.target = '_blank';
  a.rel = 'noopener';
  a.textContent = 'Read Full Article';
  content.appendChild(p);
  content.appendChild(a);
  card.appendChild(content);

  // --- Share button ---
  const shareBtn = document.createElement('button');
  shareBtn.className = 'share-btn';
  shareBtn.innerHTML = `<i class='bx bx-dots-horizontal-rounded'></i>`;
  shareBtn.addEventListener('click', async (e) => {
    e.stopPropagation();
    const articleUrl = item.link;
    if (navigator.share) {
      try {
        await navigator.share({
          title: decodeEntities(item.title || "London News"),
          text: "Check out this article:",
          url: articleUrl
        });
      } catch {}
    } else {
      await navigator.clipboard.writeText(articleUrl);
      showToast("Link copied!");
    }
  });
  card.appendChild(shareBtn);

  // --- Card click ---
  card.addEventListener('click', (e) => {
    if (e.target.tagName === 'A' || e.target.classList.contains('share-btn')) return;
    if (state.openCard && state.openCard !== card) {
      state.openCard.classList.remove('active');
    }
    const nowActive = !card.classList.contains('active');
    card.classList.toggle('active', nowActive);
    state.openCard = nowActive ? card : null;
  });

  return card;
}


function renderGrid(){
  gridEl.innerHTML = '';
  if(!state.articles.length){
    const empty = document.createElement('div');
    empty.className = 'empty';
    empty.textContent = 'No stories. Try refreshing.';
    gridEl.appendChild(empty);
    return;
  }
  const sorted = state.articles.sort((a,b)=> new Date(b.pubDate)-new Date(a.pubDate));
  sorted.forEach(item => gridEl.appendChild(item.card));
}

/* ---------- Feed loading (Worker proxy + cache) ---------- */
async function loadFeed(source){
  const cachedUrl = workerCached(source.url);
  const liveUrl   = workerLive(source.url);
  let data = null;

  try{
    const cachedRes = await fetch(cachedUrl);
    if(cachedRes.ok) data = await cachedRes.json();
  }catch{}

  if(!data || !data.items || !data.items.length){
    const liveRes = await fetch(liveUrl);
    data = await liveRes.json();
  }
  if(!data.items) return;

  // Compute per-source colours once (for no-image cards)
    if(!source._colors){
      source._colors = await getGradientFromLogo(source.logo);
    }


  for(const item of data.items){
    item.pubDate ||= item.isoDate || item.published || item.date || new Date().toISOString();

    // Decide thumbnail:
    let hasImage = !!item.thumbnail;
    // If the thumbnail is a generated placeholder URL, treat as no-image:
    if(hasImage && /placehold\.co/.test(item.thumbnail)) hasImage = false;

    // Try a Pexels fallback image if the article has no image
    //if (!hasImage) {
    //  const fallback = await getPexelsImage(cleanTitle(item.title, source.name));
    //  if (fallback) {
    //    item.thumbnail = fallback;
    //    hasImage = true;
    //  }
    //}


    const id = btoa(item.link);
    if(state.articles.some(a => a.id === id)) continue;

    const card = makeCardDOM(item, source);
    state.articles.push({ ...item, card, id });
  }
}




async function loadAllFeeds(){
  gridEl.innerHTML = '<div class="empty">Loading feedsâ€¦</div>';
  state.articles = [];

  try{
    const feedRes = await fetch('feeds.json');
    const feedData = await feedRes.json();
    state.allSources = Object.values(feedData).flat();

    await Promise.all(state.allSources.map(loadFeed));

    renderGrid();
    localStorage.setItem('feedCache_grid', JSON.stringify(state.articles.map(a=>({
      id:a.id,
      link:a.link,
      title:a.title,
      pubDate:a.pubDate,
      description:a.description,
      content:a.content,
      thumbnail:a.thumbnail || null,
      sourceName:a.card?.dataset?.source || '',
      sourceColor:a.sourceColor || null,
      darkSourceColor:a.darkSourceColor || null
    })) ));
    localStorage.setItem('feedTimestamp_grid', Date.now());
    showToast();
  }catch(err){
    gridEl.innerHTML = `<div class="empty">Error loading feeds: ${err.message}</div>`;
  }
}

/* ---------- Cached boot ---------- */
(function bootFromCache(){
  const saved = localStorage.getItem('feedCache_grid');
  const savedAt = localStorage.getItem('feedTimestamp_grid');
  if(saved && savedAt && Date.now() - savedAt < 1000*60*30){
    try{
      const cacheItems = JSON.parse(saved);
      state.articles = cacheItems.map(ci=>{
        const source = { name: ci.sourceName || 'Source', logo: null };
        const item = {
          link: ci.link, title: ci.title, pubDate: ci.pubDate,
          description: ci.description, content: ci.content,
          thumbnail: ci.thumbnail, sourceColor: ci.sourceColor, darkSourceColor: ci.darkSourceColor
        };
        const card = makeCardDOM(item, source);
        return { ...item, card, id: ci.id };
      });
      renderGrid();
    }catch(e){
      console.warn('Local cache corrupted, refetching');
    }
  }
})();




</script>

<!-- ColorThief for logo-based palette -->
<script src="https://unpkg.com/colorthief/dist/color-thief.umd.js"></script>
<script>
/* Date */
(function setDate(){
  const el=document.getElementById("currentDate");
  const today=new Date();
  el.textContent=today.toLocaleDateString("en-US",{month:"long",day:"numeric"});
})();

/* Scroll Hide/Show for Frosted Topbar */
let lastScroll=0;
const topbar=document.getElementById('topbar');
window.addEventListener('scroll',()=>{
  const curr=window.scrollY;
  if(curr>lastScroll && curr>80){ topbar.classList.add('hidden'); }
  else if(curr<lastScroll-10){ topbar.classList.remove('hidden'); }
  lastScroll=curr;
});

/* Button Logic */
const backBtn=document.getElementById('backToTopBtn');
window.addEventListener('scroll',()=>{
  if(window.scrollY>400) backBtn.classList.add('visible');
  else backBtn.classList.remove('visible');
});
backBtn.addEventListener('click',()=>window.scrollTo({top:0,behavior:'smooth'}));

const refreshBtn=document.getElementById('refreshBtn');
refreshBtn.addEventListener('click',()=>{
  const icon=refreshBtn.querySelector('i');
  icon.classList.add('bx-spin');
  setTimeout(()=>icon.classList.remove('bx-spin'),1500);
});

</script>
<script>
/* Fade between date and weather with right-side icons */
(async function fadeDateWeather(){
  const el = document.getElementById("currentDate");

  function setText(newText, instant = false){
    if (instant) {
      el.style.transition = "none";
      el.innerHTML = newText;
      el.style.opacity = 1;
      requestAnimationFrame(() => {
        el.style.transition = "opacity 0.8s ease";
      });
    } else {
      el.style.opacity = 0;
      setTimeout(() => {
        el.innerHTML = newText;
        el.style.opacity = 1;
      }, 400);
    }
  }

  // initial date (instant)
  const today = new Date();
  const dateText = today.toLocaleDateString("en-US",{month:"long",day:"numeric"});
  setText(dateText, true);

  // fetch weather
  async function getWeather(){
    try {
      const res = await fetch("https://api.open-meteo.com/v1/forecast?latitude=42.9837&longitude=-81.2497&current_weather=true");
      const data = await res.json();
      const temp = Math.round(data.current_weather.temperature);
      const symbol = "Â°C";
      const code = data.current_weather.weathercode;

      const map = [
        { codes: [0], label: "Clear", icon: "â˜€ï¸" },
        { codes: [1, 2], label: "Partly Cloudy", icon: "ðŸŒ¤ï¸" },
        { codes: [3], label: "Cloudy", icon: "â˜ï¸" },
        { codes: [45, 48], label: "Fog", icon: "ðŸŒ«ï¸" },
        { codes: [51, 53, 55], label: "Drizzle", icon: "ðŸŒ¦ï¸" },
        { codes: [61, 63, 65], label: "Rain", icon: "ðŸŒ§ï¸" },
        { codes: [66, 67], label: "Freezing Rain", icon: "ðŸŒ¨ï¸" },
        { codes: [71, 73, 75, 77, 85, 86], label: "Snow", icon: "â„ï¸" },
        { codes: [80, 81, 82], label: "Showers", icon: "ðŸŒ¦ï¸" },
        { codes: [95, 96, 99], label: "Thunderstorm", icon: "â›ˆï¸" }
      ];

      const entry = map.find(e => e.codes.includes(code)) || { label: "Unknown", icon: "ðŸŒ¡ï¸" };
      return `${temp}${symbol} â€¢ ${entry.label} ${entry.icon}`;
    } catch (e){
      console.warn("Weather fetch failed", e);
      return null;
    }
  }

  const weatherText = await getWeather();

  // alternate every 6 s
  let showingDate = true;
  setInterval(()=>{
    showingDate = !showingDate;
    setText(showingDate ? dateText : (weatherText || dateText));
  }, 3000);
})();
</script>
<script>
(async function initApp(){
  // Step 1: Load local image library first
  await loadImageLibrary();

  // Step 2: Then load feeds
  await loadAllFeeds();
})();
</script>






</body>
</html>
 

